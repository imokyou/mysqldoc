# 5.6 事务控制语句

## 概述

MySQL提供了丰富的事务控制语句，用于管理事务的开始、提交、回滚和保存点。这些语句是数据库事务管理的基础，掌握它们对于开发可靠的数据库应用程序至关重要。

## 事务开始语句

### START TRANSACTION

#### 基本语法

```sql
START TRANSACTION;
```

#### 详细说明

`START TRANSACTION`是开始一个新事务的标准语句。它会：

- 开始一个新的事务
- 禁用自动提交模式（如果启用）
- 设置事务的隔离级别（如果指定）

#### 使用示例

```sql
-- 基本用法
START TRANSACTION;
INSERT INTO users (name, email) VALUES ('张三', 'zhangsan@example.com');
UPDATE accounts SET balance = balance + 100 WHERE user_id = 1;
COMMIT;
```

#### 带选项的START TRANSACTION

```sql
-- 指定隔离级别
START TRANSACTION WITH CONSISTENT SNAPSHOT;

-- 指定读写模式
START TRANSACTION READ WRITE;  -- 默认模式
START TRANSACTION READ ONLY;    -- 只读模式
```

### BEGIN

#### 基本语法

```sql
BEGIN;
```

#### 详细说明

`BEGIN`是`START TRANSACTION`的别名，功能完全相同。它更简洁，但在某些情况下可能不够明确。

#### 使用示例

```sql
-- 使用BEGIN开始事务
BEGIN;
INSERT INTO orders (user_id, amount) VALUES (1, 100.00);
UPDATE products SET stock = stock - 1 WHERE product_id = 1;
COMMIT;
```

### BEGIN WORK

#### 基本语法

```sql
BEGIN WORK;
```

#### 详细说明

`BEGIN WORK`是`START TRANSACTION`的另一个别名，功能完全相同。这个语法在某些数据库系统中更常见。

#### 使用示例

```sql
-- 使用BEGIN WORK开始事务
BEGIN WORK;
UPDATE accounts SET balance = balance - 50 WHERE account_id = 1;
UPDATE accounts SET balance = balance + 50 WHERE account_id = 2;
COMMIT;
```

## 事务提交语句

### COMMIT

#### 基本语法

```sql
COMMIT;
```

#### 详细说明

`COMMIT`语句用于提交当前事务，使事务中的所有修改永久保存到数据库中。

#### 使用示例

```sql
-- 基本提交
START TRANSACTION;
INSERT INTO users (name, email) VALUES ('李四', 'lisi@example.com');
COMMIT;
```

#### 带选项的COMMIT

```sql
-- 提交并释放所有锁
COMMIT AND CHAIN;

-- 提交并开始新事务
COMMIT AND RELEASE;

-- 提交并关闭连接
COMMIT AND CLOSE;
```

### 自动提交模式

#### 查看自动提交状态

```sql
-- 查看当前自动提交状态
SHOW VARIABLES LIKE 'autocommit';

-- 查看当前会话的自动提交状态
SELECT @@autocommit;
```

#### 禁用自动提交

```sql
-- 禁用自动提交
SET autocommit = 0;

-- 或者
SET SESSION autocommit = 0;
```

#### 启用自动提交

```sql
-- 启用自动提交
SET autocommit = 1;

-- 或者
SET SESSION autocommit = 1;
```

#### 自动提交示例

```sql
-- 启用自动提交（默认）
SET autocommit = 1;

-- 每个语句都会自动提交
INSERT INTO users (name, email) VALUES ('王五', 'wangwu@example.com');
-- 自动提交

UPDATE accounts SET balance = balance + 100 WHERE user_id = 1;
-- 自动提交

-- 禁用自动提交
SET autocommit = 0;

-- 需要手动提交
INSERT INTO users (name, email) VALUES ('赵六', 'zhaoliu@example.com');
UPDATE accounts SET balance = balance + 100 WHERE user_id = 2;
COMMIT;  -- 手动提交
```

## 事务回滚语句

### ROLLBACK

#### 基本语法

```sql
ROLLBACK;
```

#### 详细说明

`ROLLBACK`语句用于回滚当前事务，撤销事务中的所有修改，将数据库恢复到事务开始前的状态。

#### 使用示例

```sql
-- 基本回滚
START TRANSACTION;
INSERT INTO users (name, email) VALUES ('孙七', 'sunqi@example.com');
UPDATE accounts SET balance = balance + 200 WHERE user_id = 1;
ROLLBACK;  -- 撤销所有修改
```

#### 带选项的ROLLBACK

```sql
-- 回滚并释放所有锁
ROLLBACK AND CHAIN;

-- 回滚并开始新事务
ROLLBACK AND RELEASE;
```

#### 错误处理中的回滚

```sql
-- 在存储过程中使用回滚
DELIMITER //
CREATE PROCEDURE transfer_money(
    IN from_account INT,
    IN to_account INT,
    IN amount DECIMAL(10,2)
)
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        RESIGNAL;
    END;
    
    START TRANSACTION;
    
    -- 检查余额
    SELECT balance INTO @current_balance 
    FROM accounts WHERE account_id = from_account FOR UPDATE;
    
    IF @current_balance < amount THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '余额不足';
    END IF;
    
    -- 执行转账
    UPDATE accounts SET balance = balance - amount WHERE account_id = from_account;
    UPDATE accounts SET balance = balance + amount WHERE account_id = to_account;
    
    COMMIT;
END //
DELIMITER ;
```

## 保存点（Savepoint）

### SAVEPOINT

#### 基本语法

```sql
SAVEPOINT savepoint_name;
```

#### 详细说明

保存点允许在事务内部创建回滚点，可以回滚到指定的保存点而不是整个事务。

#### 使用示例

```sql
-- 创建保存点
START TRANSACTION;
INSERT INTO users (name, email) VALUES ('周八', 'zhouba@example.com');
SAVEPOINT sp1;  -- 创建保存点

INSERT INTO users (name, email) VALUES ('吴九', 'wujiu@example.com');
SAVEPOINT sp2;  -- 创建另一个保存点

INSERT INTO users (name, email) VALUES ('郑十', 'zhengshi@example.com');

-- 回滚到sp2
ROLLBACK TO SAVEPOINT sp2;

-- 回滚到sp1
ROLLBACK TO SAVEPOINT sp1;

-- 提交事务
COMMIT;
```

### ROLLBACK TO SAVEPOINT

#### 基本语法

```sql
ROLLBACK TO SAVEPOINT savepoint_name;
```

#### 详细说明

回滚到指定的保存点，撤销从该保存点之后的所有修改，但保留保存点之前的修改。

#### 使用示例

```sql
-- 复杂事务中的保存点使用
START TRANSACTION;

-- 第一步：创建用户
INSERT INTO users (name, email) VALUES ('用户A', 'usera@example.com');
SET @user_id = LAST_INSERT_ID();
SAVEPOINT user_created;

-- 第二步：创建账户
INSERT INTO accounts (user_id, balance) VALUES (@user_id, 1000.00);
SAVEPOINT account_created;

-- 第三步：创建订单
INSERT INTO orders (user_id, amount) VALUES (@user_id, 100.00);
SAVEPOINT order_created;

-- 如果订单创建失败，回滚到账户创建
-- ROLLBACK TO SAVEPOINT account_created;

-- 如果账户创建失败，回滚到用户创建
-- ROLLBACK TO SAVEPOINT user_created;

COMMIT;
```

### RELEASE SAVEPOINT

#### 基本语法

```sql
RELEASE SAVEPOINT savepoint_name;
```

#### 详细说明

释放指定的保存点，删除该保存点。释放后无法再回滚到该保存点。

#### 使用示例

```sql
START TRANSACTION;
INSERT INTO users (name, email) VALUES ('用户B', 'userb@example.com');
SAVEPOINT sp1;

INSERT INTO users (name, email) VALUES ('用户C', 'userc@example.com');
SAVEPOINT sp2;

-- 释放保存点sp1
RELEASE SAVEPOINT sp1;

-- 现在无法回滚到sp1
-- ROLLBACK TO SAVEPOINT sp1;  -- 错误

-- 但可以回滚到sp2
ROLLBACK TO SAVEPOINT sp2;

COMMIT;
```

## 事务状态查询

### 查看当前事务状态

```sql
-- 查看当前事务状态
SELECT @@in_transaction;

-- 查看当前事务ID
SELECT @@tx_isolation;

-- 查看当前会话的事务信息
SELECT 
    trx_id,
    trx_state,
    trx_started,
    trx_mysql_thread_id,
    trx_query
FROM information_schema.innodb_trx
WHERE trx_mysql_thread_id = CONNECTION_ID();
```

### 查看活跃事务

```sql
-- 查看所有活跃事务
SELECT 
    trx_id,
    trx_state,
    trx_started,
    trx_mysql_thread_id,
    trx_query,
    TIMESTAMPDIFF(SECOND, trx_started, NOW()) as duration_seconds
FROM information_schema.innodb_trx
WHERE trx_state = 'RUNNING'
ORDER BY duration_seconds DESC;
```

## 事务控制最佳实践

### 1. 事务设计原则

```sql
-- 事务要尽可能短小
-- 错误示例：长事务
START TRANSACTION;
-- 执行大量操作
-- 长时间不提交
-- COMMIT;

-- 正确示例：将大事务拆分为小事务
START TRANSACTION;
-- 执行少量操作
COMMIT;

START TRANSACTION;
-- 执行下一批操作
COMMIT;
```

### 2. 错误处理

```sql
-- 使用存储过程进行错误处理
DELIMITER //
CREATE PROCEDURE safe_transfer(
    IN from_account INT,
    IN to_account INT,
    IN amount DECIMAL(10,2)
)
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '转账失败';
    END;
    
    START TRANSACTION;
    
    -- 检查账户是否存在
    IF NOT EXISTS (SELECT 1 FROM accounts WHERE account_id = from_account) THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '源账户不存在';
    END IF;
    
    IF NOT EXISTS (SELECT 1 FROM accounts WHERE account_id = to_account) THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '目标账户不存在';
    END IF;
    
    -- 检查余额
    SELECT balance INTO @current_balance 
    FROM accounts WHERE account_id = from_account FOR UPDATE;
    
    IF @current_balance < amount THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '余额不足';
    END IF;
    
    -- 执行转账
    UPDATE accounts SET balance = balance - amount WHERE account_id = from_account;
    UPDATE accounts SET balance = balance + amount WHERE account_id = to_account;
    
    -- 记录转账日志
    INSERT INTO transfer_logs (from_account, to_account, amount, transfer_time)
    VALUES (from_account, to_account, amount, NOW());
    
    COMMIT;
    
    SELECT '转账成功' as result;
END //
DELIMITER ;
```

### 3. 保存点使用策略

```sql
-- 使用保存点进行复杂事务管理
START TRANSACTION;

-- 第一步：验证数据
SELECT COUNT(*) INTO @user_count FROM users WHERE user_id = 1;
IF @user_count = 0 THEN
    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '用户不存在';
END IF;
SAVEPOINT validation_complete;

-- 第二步：更新用户信息
UPDATE users SET last_login = NOW() WHERE user_id = 1;
SAVEPOINT user_updated;

-- 第三步：记录登录日志
INSERT INTO login_logs (user_id, login_time, ip_address)
VALUES (1, NOW(), '192.168.1.100');
SAVEPOINT log_created;

-- 第四步：更新统计信息
UPDATE user_stats SET login_count = login_count + 1 WHERE user_id = 1;
SAVEPOINT stats_updated;

-- 如果任何步骤失败，可以回滚到相应的保存点
-- ROLLBACK TO SAVEPOINT validation_complete;
-- ROLLBACK TO SAVEPOINT user_updated;
-- ROLLBACK TO SAVEPOINT log_created;
-- ROLLBACK TO SAVEPOINT stats_updated;

COMMIT;
```

### 4. 性能优化

```sql
-- 批量操作使用事务
START TRANSACTION;

-- 批量插入
INSERT INTO users (name, email) VALUES 
('用户1', 'user1@example.com'),
('用户2', 'user2@example.com'),
('用户3', 'user3@example.com'),
('用户4', 'user4@example.com'),
('用户5', 'user5@example.com');

-- 批量更新
UPDATE accounts SET balance = balance * 1.05 WHERE balance > 1000;

COMMIT;
```

## 实际应用示例

### 1. 银行转账系统

```sql
-- 完整的银行转账实现
DELIMITER //
CREATE PROCEDURE bank_transfer(
    IN from_account INT,
    IN to_account INT,
    IN transfer_amount DECIMAL(10,2)
)
BEGIN
    DECLARE from_balance DECIMAL(10,2);
    DECLARE to_balance DECIMAL(10,2);
    DECLARE transfer_id INT;
    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '转账失败';
    END;
    
    START TRANSACTION;
    
    -- 获取账户余额并加锁
    SELECT balance INTO from_balance 
    FROM accounts WHERE account_id = from_account FOR UPDATE;
    
    SELECT balance INTO to_balance 
    FROM accounts WHERE account_id = to_account FOR UPDATE;
    
    -- 验证余额
    IF from_balance < transfer_amount THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '余额不足';
    END IF;
    
    -- 执行转账
    UPDATE accounts SET balance = balance - transfer_amount 
    WHERE account_id = from_account;
    
    UPDATE accounts SET balance = balance + transfer_amount 
    WHERE account_id = to_account;
    
    -- 记录转账日志
    INSERT INTO transfer_logs (from_account, to_account, amount, transfer_time)
    VALUES (from_account, to_account, transfer_amount, NOW());
    
    SET transfer_id = LAST_INSERT_ID();
    
    -- 验证转账结果
    SELECT SUM(balance) INTO @total_balance 
    FROM accounts WHERE account_id IN (from_account, to_account);
    
    IF @total_balance != (from_balance + to_balance) THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '转账金额不一致';
    END IF;
    
    COMMIT;
    
    SELECT transfer_id as transfer_id, '转账成功' as status;
END //
DELIMITER ;
```

### 2. 订单处理系统

```sql
-- 订单处理事务
DELIMITER //
CREATE PROCEDURE process_order(
    IN user_id INT,
    IN product_id INT,
    IN quantity INT
)
BEGIN
    DECLARE product_price DECIMAL(10,2);
    DECLARE product_stock INT;
    DECLARE order_id INT;
    DECLARE total_amount DECIMAL(10,2);
    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '订单处理失败';
    END;
    
    START TRANSACTION;
    
    -- 获取商品信息
    SELECT price, stock INTO product_price, product_stock
    FROM products WHERE product_id = product_id FOR UPDATE;
    
    -- 检查库存
    IF product_stock < quantity THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '库存不足';
    END IF;
    
    -- 计算总金额
    SET total_amount = product_price * quantity;
    
    -- 创建订单
    INSERT INTO orders (user_id, total_amount, status, created_at)
    VALUES (user_id, total_amount, 'pending', NOW());
    
    SET order_id = LAST_INSERT_ID();
    
    -- 创建订单项
    INSERT INTO order_items (order_id, product_id, quantity, price)
    VALUES (order_id, product_id, quantity, product_price);
    
    -- 更新库存
    UPDATE products SET stock = stock - quantity WHERE product_id = product_id;
    
    -- 更新订单状态
    UPDATE orders SET status = 'confirmed' WHERE order_id = order_id;
    
    COMMIT;
    
    SELECT order_id as order_id, total_amount as total_amount, '订单创建成功' as status;
END //
DELIMITER ;
```

## 总结

MySQL的事务控制语句提供了完整的事务管理功能：

1. **事务开始**：`START TRANSACTION`、`BEGIN`、`BEGIN WORK`
2. **事务提交**：`COMMIT`及其变体
3. **事务回滚**：`ROLLBACK`及其变体
4. **保存点**：`SAVEPOINT`、`ROLLBACK TO SAVEPOINT`、`RELEASE SAVEPOINT`

在实际应用中，需要根据业务需求合理使用这些语句，并注意事务的设计原则和性能优化。 

**[返回目录 README.md](./README?id=_5-mysql-事务管理)** 