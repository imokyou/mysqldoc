# MySQL 主从切换

## 概述

MySQL主从切换是数据库高可用架构中的关键操作，用于在主库发生故障时快速切换到从库，确保业务的连续性。主从切换包括手动切换和自动切换两种方式，需要根据业务需求和系统架构选择合适的切换策略。

## 主从架构

### 1. 基本架构

#### 1.1 一主一从架构
```
主库 (Master) ←→ 从库 (Slave)
     ↓              ↓
   写操作          读操作
   数据变更        数据查询
```

#### 1.2 一主多从架构
```
主库 (Master)
    ↓
    ├── 从库1 (Slave1) - 读操作
    ├── 从库2 (Slave2) - 读操作
    └── 从库3 (Slave3) - 读操作
```

#### 1.3 主主架构
```
主库1 (Master1) ←→ 主库2 (Master2)
    ↓                ↓
  写操作1           写操作2
  数据变更1         数据变更2
```

### 2. 切换场景

#### 2.1 计划内切换
- 主库维护升级
- 硬件更换
- 系统优化
- 版本升级

#### 2.2 计划外切换
- 主库硬件故障
- 网络中断
- 系统崩溃
- 数据损坏

## 手动切换

### 1. 切换前准备

#### 1.1 检查主从状态
```sql
-- 检查主库状态
SHOW MASTER STATUS;

-- 检查从库状态
SHOW SLAVE STATUS\G

-- 检查从库延迟
SELECT 
    Seconds_Behind_Master,
    Slave_IO_Running,
    Slave_SQL_Running
FROM performance_schema.replication_connection_status;
```

#### 1.2 验证数据一致性
```sql
-- 检查主从数据一致性
-- 在主库执行
SELECT COUNT(*) FROM table_name;

-- 在从库执行
SELECT COUNT(*) FROM table_name;

-- 比较结果是否一致
```

#### 1.3 停止应用写入
```bash
# 停止应用服务
systemctl stop myapp

# 或者修改应用配置，停止写入主库
# 确保所有写操作都停止
```

### 2. 执行切换

#### 2.1 提升从库为主库
```sql
-- 在从库上执行
-- 停止从库复制
STOP SLAVE;

-- 重置从库配置
RESET SLAVE ALL;

-- 启用二进制日志（如果之前禁用）
SET GLOBAL log_bin = ON;
SET GLOBAL server_id = 1; -- 设置新的server_id

-- 创建新的复制用户
CREATE USER 'repl'@'%' IDENTIFIED BY 'password';
GRANT REPLICATION SLAVE ON *.* TO 'repl'@'%';
FLUSH PRIVILEGES;
```

#### 2.2 配置其他从库
```sql
-- 在其他从库上重新配置复制
STOP SLAVE;
CHANGE MASTER TO
    MASTER_HOST='new_master_ip',
    MASTER_USER='repl',
    MASTER_PASSWORD='password',
    MASTER_LOG_FILE='mysql-bin.000001',
    MASTER_LOG_POS=123;
START SLAVE;
```

#### 2.3 切换应用配置
```bash
# 修改应用配置文件
# 将主库地址改为新的主库地址
sed -i 's/old_master_ip/new_master_ip/g' /etc/myapp/config.ini

# 重启应用服务
systemctl start myapp
```

### 3. 切换后验证

#### 3.1 验证新主库状态
```sql
-- 检查新主库状态
SHOW MASTER STATUS;

-- 检查新主库进程
SHOW PROCESSLIST;

-- 验证数据完整性
SELECT COUNT(*) FROM important_table;
```

#### 3.2 验证从库复制状态
```sql
-- 检查所有从库状态
SHOW SLAVE STATUS\G

-- 检查复制延迟
SELECT 
    Seconds_Behind_Master,
    Slave_IO_Running,
    Slave_SQL_Running
FROM performance_schema.replication_connection_status;
```

## 自动切换

### 1. 使用代理工具

#### 1.1 MySQL Router
```ini
# MySQL Router 配置
[DEFAULT]
user=mysqlrouter
keyring_path=/var/lib/mysqlrouter/keyring

[metadata_cache:prod]
router_id=1
bootstrap_server_addresses=mysqlserver1:3306,mysqlserver2:3306
user=mysqlrouter
metadata_cluster=prod

[routing:read_write]
bind_address=0.0.0.0
bind_port=6446
destinations=metadata-cache://prod/?role=PRIMARY
routing_strategy=first-available

[routing:read_only]
bind_address=0.0.0.0
bind_port=6447
destinations=metadata-cache://prod/?role=SECONDARY
routing_strategy=round-robin
```

#### 1.2 ProxySQL
```sql
-- 配置ProxySQL
INSERT INTO mysql_servers (hostgroup_id, hostname, port) VALUES
(10, 'master_ip', 3306),
(20, 'slave1_ip', 3306),
(20, 'slave2_ip', 3306);

-- 配置用户
INSERT INTO mysql_users (username, password, default_hostgroup) VALUES
('app_user', 'password', 10);

-- 配置查询规则
INSERT INTO mysql_query_rules (rule_id, active, match_pattern, destination_hostgroup) VALUES
(1, 1, '^SELECT', 20),
(2, 1, '^INSERT|^UPDATE|^DELETE', 10);
```

### 2. 使用集群管理工具

#### 2.1 MHA (Master High Availability)
```bash
# MHA 配置文件
[server default]
user=mha
password=mha
ssh_user=root
repl_user=repl
repl_password=repl
ping_interval=3
master_ip_failover_script=/usr/local/bin/master_ip_failover
master_ip_online_change_script=/usr/local/bin/master_ip_online_change

[server1]
hostname=master
port=3306

[server2]
hostname=slave1
port=3306
candidate_master=1

[server3]
hostname=slave2
port=3306
```

#### 2.2 Orchestrator
```yaml
# Orchestrator 配置
{
  "MySQLTopologyCredentialsConfigFile": "/etc/orchestrator/credentials.json",
  "MySQLTopologySSLPrivateKeyFile": "",
  "MySQLTopologySSLCertFile": "",
  "MySQLTopologySSLCAFile": "",
  "MySQLTopologySSLSkipVerify": true,
  "MySQLTopologyUseMutualTLS": false,
  "MySQLTopologyCredentialsConfigFile": "/etc/orchestrator/credentials.json",
  "MySQLTopologySSLPrivateKeyFile": "",
  "MySQLTopologySSLCertFile": "",
  "MySQLTopologySSLCAFile": "",
  "MySQLTopologySSLSkipVerify": true,
  "MySQLTopologyUseMutualTLS": false
}
```

### 3. 自定义切换脚本

#### 3.1 心跳检测脚本
```bash
#!/bin/bash
# heartbeat_check.sh

MASTER_HOST="master_ip"
SLAVE_HOST="slave_ip"
MYSQL_USER="root"
MYSQL_PASS="password"
LOG_FILE="/var/log/mysql_switch.log"

# 日志函数
log() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" >> $LOG_FILE
}

# 检查主库连接
check_master() {
    mysql -h$MASTER_HOST -u$MYSQL_USER -p$MYSQL_PASS -e "SELECT 1;" > /dev/null 2>&1
    return $?
}

# 检查从库状态
check_slave() {
    SLAVE_STATUS=$(mysql -h$SLAVE_HOST -u$MYSQL_USER -p$MYSQL_PASS -e "SHOW SLAVE STATUS\G" | grep -E "(Slave_IO_Running|Slave_SQL_Running)" | awk '{print $2}')
    echo $SLAVE_STATUS
}

# 主切换逻辑
if ! check_master; then
    log "主库连接失败，开始切换"
    
    # 检查从库状态
    SLAVE_STATUS=$(check_slave)
    
    if [[ $SLAVE_STATUS == *"Yes"* ]]; then
        log "从库状态正常，执行切换"
        
        # 停止从库复制
        mysql -h$SLAVE_HOST -u$MYSQL_USER -p$MYSQL_PASS -e "STOP SLAVE;"
        
        # 重置从库配置
        mysql -h$SLAVE_HOST -u$MYSQL_USER -p$MYSQL_PASS -e "RESET SLAVE ALL;"
        
        # 启用二进制日志
        mysql -h$SLAVE_HOST -u$MYSQL_USER -p$MYSQL_PASS -e "SET GLOBAL log_bin = ON;"
        
        log "切换完成"
        
        # 通知应用切换
        # 这里可以添加通知应用的代码
    else
        log "从库状态异常，切换失败"
    fi
else
    log "主库状态正常"
fi
```

#### 3.2 自动切换脚本
```python
#!/usr/bin/env python3
# auto_failover.py

import mysql.connector
import time
import logging
import subprocess

# 配置
MASTER_CONFIG = {
    'host': 'master_ip',
    'user': 'root',
    'password': 'password',
    'port': 3306
}

SLAVE_CONFIG = {
    'host': 'slave_ip',
    'user': 'root',
    'password': 'password',
    'port': 3306
}

# 日志配置
logging.basicConfig(
    filename='/var/log/mysql_failover.log',
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)

def check_connection(config):
    """检查数据库连接"""
    try:
        conn = mysql.connector.connect(**config)
        conn.close()
        return True
    except:
        return False

def check_slave_status(config):
    """检查从库状态"""
    try:
        conn = mysql.connector.connect(**config)
        cursor = conn.cursor()
        cursor.execute("SHOW SLAVE STATUS")
        result = cursor.fetchone()
        cursor.close()
        conn.close()
        
        if result:
            # 检查Slave_IO_Running和Slave_SQL_Running
            return result[10] == 'Yes' and result[11] == 'Yes'
        return False
    except:
        return False

def promote_slave_to_master():
    """提升从库为主库"""
    try:
        conn = mysql.connector.connect(**SLAVE_CONFIG)
        cursor = conn.cursor()
        
        # 停止从库复制
        cursor.execute("STOP SLAVE")
        
        # 重置从库配置
        cursor.execute("RESET SLAVE ALL")
        
        # 启用二进制日志
        cursor.execute("SET GLOBAL log_bin = ON")
        
        conn.commit()
        cursor.close()
        conn.close()
        
        logging.info("从库已提升为主库")
        return True
    except Exception as e:
        logging.error(f"提升从库失败: {e}")
        return False

def update_application_config():
    """更新应用配置"""
    try:
        # 更新应用配置文件
        subprocess.run([
            'sed', '-i', 
            's/master_ip/slave_ip/g', 
            '/etc/myapp/config.ini'
        ])
        
        # 重启应用服务
        subprocess.run(['systemctl', 'restart', 'myapp'])
        
        logging.info("应用配置已更新")
        return True
    except Exception as e:
        logging.error(f"更新应用配置失败: {e}")
        return False

def main():
    """主函数"""
    while True:
        # 检查主库连接
        if not check_connection(MASTER_CONFIG):
            logging.warning("主库连接失败")
            
            # 检查从库状态
            if check_slave_status(SLAVE_CONFIG):
                logging.info("从库状态正常，开始切换")
                
                # 提升从库为主库
                if promote_slave_to_master():
                    # 更新应用配置
                    update_application_config()
                    logging.info("切换完成")
                    break
                else:
                    logging.error("切换失败")
            else:
                logging.error("从库状态异常")
        else:
            logging.info("主库状态正常")
        
        # 等待5秒后再次检查
        time.sleep(5)

if __name__ == "__main__":
    main()
```

## 故障检测

### 1. 心跳检测

#### 1.1 网络心跳
```bash
#!/bin/bash
# network_heartbeat.sh

MASTER_HOST="master_ip"
PING_COUNT=3
TIMEOUT=5

# 检查网络连通性
if ping -c $PING_COUNT -W $TIMEOUT $MASTER_HOST > /dev/null 2>&1; then
    echo "网络连接正常"
    exit 0
else
    echo "网络连接异常"
    exit 1
fi
```

#### 1.2 数据库心跳
```sql
-- 创建心跳表
CREATE TABLE heartbeat (
    id INT PRIMARY KEY,
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- 插入心跳记录
INSERT INTO heartbeat (id) VALUES (1) ON DUPLICATE KEY UPDATE id=id;

-- 检查心跳
SELECT timestamp FROM heartbeat WHERE id = 1;
```

### 2. 监控指标

#### 2.1 关键监控指标
```sql
-- 监控主库状态
SELECT 
    @@hostname as hostname,
    @@port as port,
    @@server_id as server_id,
    @@read_only as read_only,
    @@log_bin as log_bin,
    @@binlog_format as binlog_format;

-- 监控从库状态
SELECT 
    Slave_IO_State,
    Master_Host,
    Master_Port,
    Connect_Retry,
    Master_Log_File,
    Read_Master_Log_Pos,
    Relay_Log_File,
    Relay_Log_Pos,
    Relay_Master_Log_File,
    Slave_IO_Running,
    Slave_SQL_Running,
    Replicate_Do_DB,
    Replicate_Ignore_DB,
    Replicate_Do_Table,
    Replicate_Ignore_Table,
    Replicate_Wild_Do_Table,
    Replicate_Wild_Ignore_Table,
    Last_Errno,
    Last_Error,
    Skip_Counter,
    Exec_Master_Log_Pos,
    Relay_Log_Space,
    Until_Condition,
    Until_Log_File,
    Until_Log_Pos,
    Master_SSL_Allowed,
    Master_SSL_CA_File,
    Master_SSL_CA_Path,
    Master_SSL_Cert,
    Master_SSL_Cipher,
    Master_SSL_Key,
    Seconds_Behind_Master,
    Master_SSL_Verify_Server_Cert,
    Last_IO_Errno,
    Last_IO_Error,
    Last_SQL_Errno,
    Last_SQL_Error,
    Replicate_Ignore_Server_Ids,
    Master_Server_Id,
    Master_UUID,
    Master_Info_File,
    SQL_Delay,
    SQL_Remaining_Delay,
    Slave_SQL_Running_State,
    Master_Retry_Count,
    Master_Bind,
    Last_IO_Error_Timestamp,
    Last_SQL_Error_Timestamp,
    Master_SSL_Crl,
    Master_SSL_Crlpath,
    Retrieved_Gtid_Set,
    Executed_Gtid_Set,
    Auto_Position,
    Replicate_Rewrite_DB,
    Channel_Name,
    Master_TLS_Version
FROM performance_schema.replication_connection_status;
```

#### 2.2 延迟监控
```sql
-- 监控复制延迟
SELECT 
    Seconds_Behind_Master,
    Slave_IO_Running,
    Slave_SQL_Running
FROM performance_schema.replication_connection_status;

-- 监控延迟趋势
SELECT 
    DATE(created_at) as date,
    AVG(seconds_behind_master) as avg_delay,
    MAX(seconds_behind_master) as max_delay,
    MIN(seconds_behind_master) as min_delay
FROM replication_delay_log
WHERE created_at > DATE_SUB(NOW(), INTERVAL 1 DAY)
GROUP BY DATE(created_at);
```

### 3. 告警机制

#### 3.1 告警脚本
```bash
#!/bin/bash
# replication_alert.sh

MASTER_HOST="master_ip"
SLAVE_HOST="slave_ip"
MYSQL_USER="root"
MYSQL_PASS="password"
ALERT_EMAIL="admin@example.com"
LOG_FILE="/var/log/replication_alert.log"

# 检查主库状态
check_master() {
    mysql -h$MASTER_HOST -u$MYSQL_USER -p$MYSQL_PASS -e "SELECT 1;" > /dev/null 2>&1
    return $?
}

# 检查从库状态
check_slave() {
    SLAVE_STATUS=$(mysql -h$SLAVE_HOST -u$MYSQL_USER -p$MYSQL_PASS -e "SHOW SLAVE STATUS\G" | grep -E "(Slave_IO_Running|Slave_SQL_Running)" | awk '{print $2}')
    echo $SLAVE_STATUS
}

# 检查复制延迟
check_delay() {
    DELAY=$(mysql -h$SLAVE_HOST -u$MYSQL_USER -p$MYSQL_PASS -e "SHOW SLAVE STATUS\G" | grep "Seconds_Behind_Master" | awk '{print $2}')
    echo $DELAY
}

# 发送告警
send_alert() {
    local message="$1"
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $message" >> $LOG_FILE
    echo "$message" | mail -s "MySQL复制告警" $ALERT_EMAIL
}

# 主检查逻辑
if ! check_master; then
    send_alert "主库连接失败"
fi

SLAVE_STATUS=$(check_slave)
if [[ $SLAVE_STATUS != *"Yes"* ]]; then
    send_alert "从库复制状态异常: $SLAVE_STATUS"
fi

DELAY=$(check_delay)
if [ "$DELAY" != "NULL" ] && [ $DELAY -gt 300 ]; then
    send_alert "复制延迟超过5分钟: ${DELAY}秒"
fi
```

## 切换策略

### 1. 切换策略选择

#### 1.1 基于延迟的切换
```python
def delay_based_failover():
    """基于延迟的切换策略"""
    slave_delay = get_slave_delay()
    
    if slave_delay > 300:  # 延迟超过5分钟
        return False  # 不切换
    
    if slave_delay < 30:   # 延迟小于30秒
        return True   # 可以切换
    
    # 延迟在30秒到5分钟之间，需要进一步评估
    return evaluate_other_factors()
```

#### 1.2 基于数据一致性的切换
```python
def consistency_based_failover():
    """基于数据一致性的切换策略"""
    # 检查主从数据一致性
    master_count = get_master_record_count()
    slave_count = get_slave_record_count()
    
    if abs(master_count - slave_count) > 1000:
        return False  # 数据差异太大，不切换
    
    # 检查关键表的一致性
    if not check_critical_tables_consistency():
        return False
    
    return True
```

### 2. 切换优先级

#### 2.1 从库优先级配置
```sql
-- 设置从库优先级
CHANGE MASTER TO
    MASTER_HOST='master_ip',
    MASTER_USER='repl',
    MASTER_PASSWORD='password',
    MASTER_LOG_FILE='mysql-bin.000001',
    MASTER_LOG_POS=123,
    MASTER_CONNECT_RETRY=10,
    MASTER_RETRY_COUNT=3;
```

#### 2.2 自动选择最佳从库
```python
def select_best_slave():
    """选择最佳从库"""
    slaves = get_all_slaves()
    best_slave = None
    min_delay = float('inf')
    
    for slave in slaves:
        delay = get_slave_delay(slave)
        if delay is not None and delay < min_delay:
            min_delay = delay
            best_slave = slave
    
    return best_slave
```

## 最佳实践

### 1. 切换前准备

#### 1.1 检查清单
- [ ] 验证主从数据一致性
- [ ] 检查从库复制状态
- [ ] 确认应用可以承受切换
- [ ] 准备回滚方案
- [ ] 通知相关人员

#### 1.2 切换测试
```bash
# 定期进行切换测试
#!/bin/bash
# failover_test.sh

echo "开始切换测试"
# 模拟主库故障
# 执行切换流程
# 验证切换结果
# 恢复原状态
echo "切换测试完成"
```

### 2. 切换后处理

#### 2.1 验证清单
- [ ] 验证新主库状态
- [ ] 检查应用连接
- [ ] 验证数据完整性
- [ ] 监控系统性能
- [ ] 更新文档

#### 2.2 故障恢复
```bash
# 原主库恢复后的处理
#!/bin/bash
# master_recovery.sh

# 检查原主库状态
# 配置为从库
# 启动复制
# 验证复制状态
# 更新应用配置（如果需要）
```

### 3. 监控和维护

#### 3.1 持续监控
```sql
-- 定期检查复制状态
SELECT 
    @@hostname as hostname,
    @@server_id as server_id,
    @@read_only as read_only,
    (SELECT COUNT(*) FROM information_schema.processlist) as connections,
    (SELECT SUM(rows_sent) FROM performance_schema.events_statements_summary_global_by_event_name) as queries;
```

#### 3.2 性能优化
```sql
-- 优化新主库性能
SET GLOBAL innodb_buffer_pool_size = 1073741824; -- 1GB
SET GLOBAL max_connections = 200;
SET GLOBAL query_cache_size = 67108864; -- 64MB
```

## 总结

MySQL主从切换是确保数据库高可用的关键操作：

1. **充分准备**：切换前进行全面的检查和测试
2. **自动化工具**：使用成熟的工具减少人工错误
3. **监控告警**：建立完善的监控和告警机制
4. **快速响应**：制定详细的切换流程和应急预案
5. **持续优化**：根据实际运行情况不断优化切换策略

通过以上措施，可以确保MySQL主从切换的可靠性和效率。 

**[返回目录 README.md](./README?id=_12-mysql-高可用)** 