# 5.3 事务隔离级别

## 概述

事务隔离级别是数据库管理系统用来控制并发事务之间相互影响程度的机制。MySQL支持四种隔离级别，每种级别提供不同程度的数据一致性和并发性能。

## 隔离级别分类

### 1. READ UNCOMMITTED（读未提交）

#### 特点
- **最低隔离级别**
- **可能读取到未提交的数据（脏读）**
- **性能最好，但数据一致性最差**
- **很少在实际生产环境中使用**

#### 实现原理
```sql
-- 设置隔离级别
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

-- 查看当前隔离级别
SELECT @@transaction_isolation;
```

#### 详细示例

```sql
-- 创建测试表
CREATE TABLE test_uncommitted (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    balance DECIMAL(10,2)
);

INSERT INTO test_uncommitted VALUES (1, '张三', 1000.00);

-- 事务A：修改数据但不提交
START TRANSACTION;
UPDATE test_uncommitted SET balance = 2000.00 WHERE id = 1;
-- 此时数据还未提交

-- 事务B：可以读取到未提交的数据
START TRANSACTION;
SELECT balance FROM test_uncommitted WHERE id = 1;  -- 会看到2000.00
COMMIT;

-- 事务A回滚
ROLLBACK;

-- 事务B再次读取
SELECT balance FROM test_uncommitted WHERE id = 1;  -- 看到1000.00
COMMIT;
```

#### 脏读问题演示

```sql
-- 演示脏读问题
-- 事务A
START TRANSACTION;
UPDATE test_uncommitted SET name = '李四' WHERE id = 1;
-- 不提交，继续执行其他操作

-- 事务B（同时执行）
START TRANSACTION;
SELECT name FROM test_uncommitted WHERE id = 1;  -- 读取到'李四'
-- 基于这个未提交的数据做业务决策

-- 事务A回滚
ROLLBACK;

-- 事务B再次读取
SELECT name FROM test_uncommitted WHERE id = 1;  -- 看到'张三'
-- 之前基于'李四'做的决策是错误的
COMMIT;
```

### 2. READ COMMITTED（读已提交）

#### 特点
- **只能读取已提交的数据**
- **避免脏读，但可能出现不可重复读**
- **Oracle默认隔离级别**
- **性能较好，一致性较好**

#### 实现原理
```sql
-- 设置隔离级别
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
```

#### 详细示例

```sql
-- 测试READ COMMITTED
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- 事务A：修改数据
START TRANSACTION;
UPDATE test_uncommitted SET balance = 1500.00 WHERE id = 1;
-- 此时数据还未提交

-- 事务B：无法读取到未提交的数据
START TRANSACTION;
SELECT balance FROM test_uncommitted WHERE id = 1;  -- 仍然看到1000.00
COMMIT;

-- 事务A提交
COMMIT;

-- 事务B再次读取
SELECT balance FROM test_uncommitted WHERE id = 1;  -- 现在看到1500.00
COMMIT;
```

#### 不可重复读问题演示

```sql
-- 演示不可重复读问题
-- 事务A
START TRANSACTION;
SELECT balance FROM test_uncommitted WHERE id = 1;  -- 第一次读取：1500.00

-- 事务B（同时执行）
START TRANSACTION;
UPDATE test_uncommitted SET balance = 2000.00 WHERE id = 1;
COMMIT;

-- 事务A再次读取
SELECT balance FROM test_uncommitted WHERE id = 1;  -- 第二次读取：2000.00
-- 同一事务内两次读取结果不一致
COMMIT;
```

### 3. REPEATABLE READ（可重复读）

#### 特点
- **事务期间多次读取结果一致**
- **避免脏读和不可重复读**
- **MySQL InnoDB默认隔离级别**
- **可能出现幻读**

#### 实现原理
```sql
-- 设置隔离级别
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
```

#### 详细示例

```sql
-- 测试REPEATABLE READ
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;

-- 事务A：开始事务并读取数据
START TRANSACTION;
SELECT balance FROM test_uncommitted WHERE id = 1;  -- 第一次读取

-- 事务B：修改数据并提交
START TRANSACTION;
UPDATE test_uncommitted SET balance = 2500.00 WHERE id = 1;
COMMIT;

-- 事务A再次读取
SELECT balance FROM test_uncommitted WHERE id = 1;  -- 仍然看到之前的值
-- 同一事务内读取结果一致
COMMIT;
```

#### 幻读问题演示

```sql
-- 创建测试表
CREATE TABLE test_phantom (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50),
    amount DECIMAL(10,2)
);

INSERT INTO test_phantom (name, amount) VALUES 
('产品A', 100.00),
('产品B', 200.00),
('产品C', 300.00);

-- 事务A：查询金额大于150的产品
START TRANSACTION;
SELECT COUNT(*) FROM test_phantom WHERE amount > 150;  -- 返回2

-- 事务B：插入新记录
START TRANSACTION;
INSERT INTO test_phantom (name, amount) VALUES ('产品D', 400.00);
COMMIT;

-- 事务A再次查询
SELECT COUNT(*) FROM test_phantom WHERE amount > 150;  -- 仍然返回2
-- 但是范围查询可能看到新插入的数据
SELECT * FROM test_phantom WHERE amount > 150;  -- 可能看到产品D
COMMIT;
```

### 4. SERIALIZABLE（串行化）

#### 特点
- **最高隔离级别**
- **完全串行执行，避免所有并发问题**
- **性能最差，但数据一致性最好**
- **适用于对数据一致性要求极高的场景**

#### 实现原理
```sql
-- 设置隔离级别
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;
```

#### 详细示例

```sql
-- 测试SERIALIZABLE
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;

-- 事务A：开始事务
START TRANSACTION;
SELECT * FROM test_phantom WHERE amount > 150;

-- 事务B：尝试插入数据（会被阻塞）
START TRANSACTION;
INSERT INTO test_phantom (name, amount) VALUES ('产品E', 500.00);
-- 这个操作会被阻塞，直到事务A提交或回滚

-- 事务A提交
COMMIT;

-- 事务B现在可以继续执行
COMMIT;
```

## 隔离级别对比

### 并发问题对比表

| 隔离级别 | 脏读 | 不可重复读 | 幻读 | 性能 | 一致性 |
|---------|------|-----------|------|------|--------|
| READ UNCOMMITTED | 可能 | 可能 | 可能 | 最好 | 最差 |
| READ COMMITTED | 不可能 | 可能 | 可能 | 较好 | 较好 |
| REPEATABLE READ | 不可能 | 不可能 | 可能 | 一般 | 好 |
| SERIALIZABLE | 不可能 | 不可能 | 不可能 | 最差 | 最好 |

### 性能影响分析

```sql
-- 测试不同隔离级别的性能
-- 创建测试表
CREATE TABLE performance_test (
    id INT PRIMARY KEY AUTO_INCREMENT,
    data VARCHAR(100),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 插入测试数据
INSERT INTO performance_test (data) 
SELECT CONCAT('数据', FLOOR(RAND() * 1000)) 
FROM information_schema.columns 
LIMIT 10000;
```

#### 性能测试脚本

```sql
-- READ UNCOMMITTED性能测试
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
START TRANSACTION;
SELECT COUNT(*) FROM performance_test WHERE data LIKE '%数据%';
COMMIT;

-- READ COMMITTED性能测试
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
START TRANSACTION;
SELECT COUNT(*) FROM performance_test WHERE data LIKE '%数据%';
COMMIT;

-- REPEATABLE READ性能测试
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
START TRANSACTION;
SELECT COUNT(*) FROM performance_test WHERE data LIKE '%数据%';
COMMIT;

-- SERIALIZABLE性能测试
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;
START TRANSACTION;
SELECT COUNT(*) FROM performance_test WHERE data LIKE '%数据%';
COMMIT;
```

## 隔离级别配置

### 全局配置

```sql
-- 设置全局隔离级别
SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;

-- 查看全局隔离级别
SELECT @@global.transaction_isolation;
```

### 会话配置

```sql
-- 设置当前会话隔离级别
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- 查看当前会话隔离级别
SELECT @@session.transaction_isolation;
```

### 配置文件设置

```ini
# my.cnf 配置文件
[mysqld]
transaction-isolation = REPEATABLE-READ
```

## 实际应用场景

### 1. 高并发读场景

```sql
-- 适用于报表查询、数据分析等场景
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- 示例：生成销售报表
START TRANSACTION;
SELECT 
    DATE(created_at) as sale_date,
    COUNT(*) as order_count,
    SUM(amount) as total_amount
FROM orders 
WHERE created_at >= '2024-01-01'
GROUP BY DATE(created_at);
COMMIT;
```

### 2. 数据一致性要求高的场景

```sql
-- 适用于财务系统、银行系统等
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;

-- 示例：银行转账
START TRANSACTION;
-- 检查账户余额
SELECT balance FROM accounts WHERE account_id = 1 FOR UPDATE;
SELECT balance FROM accounts WHERE account_id = 2 FOR UPDATE;

-- 执行转账
UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;
UPDATE accounts SET balance = balance + 100 WHERE account_id = 2;

COMMIT;
```

### 3. 关键业务系统

```sql
-- 适用于对数据一致性要求极高的场景
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;

-- 示例：库存管理
START TRANSACTION;
-- 检查库存
SELECT stock FROM products WHERE product_id = 1 FOR UPDATE;

-- 如果库存充足，减少库存
UPDATE products SET stock = stock - 1 WHERE product_id = 1 AND stock > 0;

-- 创建订单
INSERT INTO orders (product_id, quantity, status) VALUES (1, 1, 'confirmed');

COMMIT;
```

## 监控和诊断

### 查看当前隔离级别

```sql
-- 查看当前隔离级别
SELECT @@transaction_isolation;

-- 查看所有会话的隔离级别
SELECT 
    session_id,
    transaction_isolation
FROM performance_schema.sessions;
```

### 监控事务冲突

```sql
-- 查看锁等待情况
SELECT 
    r.trx_id waiting_trx_id,
    r.trx_mysql_thread_id waiting_thread,
    r.trx_query waiting_query,
    b.trx_id blocking_trx_id,
    b.trx_mysql_thread_id blocking_thread,
    b.trx_query blocking_query
FROM information_schema.innodb_lock_waits w
INNER JOIN information_schema.innodb_trx b ON b.trx_id = w.blocking_trx_id
INNER JOIN information_schema.innodb_trx r ON r.trx_id = w.requesting_trx_id;
```

### 性能监控

```sql
-- 监控事务执行时间
SELECT 
    event_name,
    COUNT(*) as event_count,
    AVG(timer_wait) as avg_wait_time
FROM performance_schema.events_transactions_current
GROUP BY event_name;
```

## 最佳实践

### 1. 选择合适的隔离级别

```sql
-- 根据业务需求选择隔离级别
-- 高并发读场景
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- 数据一致性要求高的场景
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;

-- 关键业务系统
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;
```

### 2. 避免长事务

```sql
-- 长事务会增加锁持有时间，影响并发性能
-- 错误示例
START TRANSACTION;
-- 执行大量操作
-- ...
-- 长时间不提交
-- COMMIT;

-- 正确示例：将大事务拆分为小事务
START TRANSACTION;
-- 执行少量操作
COMMIT;

START TRANSACTION;
-- 执行下一批操作
COMMIT;
```

### 3. 合理使用锁

```sql
-- 使用行锁而不是表锁
SELECT * FROM accounts WHERE id = 1 FOR UPDATE;  -- 行锁

-- 避免不必要的锁
SELECT * FROM accounts WHERE id = 1;  -- 普通查询，不需要锁
```

## 总结

事务隔离级别是MySQL并发控制的核心机制，不同的隔离级别在性能和一致性之间提供不同的平衡：

- **READ UNCOMMITTED**：性能最好，但存在脏读问题
- **READ COMMITTED**：性能较好，避免脏读，但存在不可重复读
- **REPEATABLE READ**：MySQL默认级别，平衡了性能和一致性
- **SERIALIZABLE**：一致性最好，但性能最差

在实际应用中，需要根据业务需求选择合适的隔离级别，并在必要时进行性能监控和优化。 

**[返回目录 README.md](./README?id=_5-mysql-事务管理)** 