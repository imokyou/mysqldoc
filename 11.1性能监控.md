# MySQL 性能监控

## 概述

MySQL性能监控是数据库管理的重要组成部分，通过实时监控数据库的运行状态，可以及时发现性能瓶颈，优化系统性能，确保数据库的稳定运行。本文档将详细介绍MySQL性能监控的方法、工具和最佳实践。

## 监控指标体系

### 1. 连接监控

#### 1.1 连接状态指标
```sql
-- 查看当前连接数
SHOW STATUS LIKE 'Threads_connected';

-- 查看最大连接数
SHOW VARIABLES LIKE 'max_connections';

-- 查看连接使用率
SELECT 
    ROUND(Threads_connected / max_connections * 100, 2) as connection_usage_percent
FROM performance_schema.global_status 
JOIN performance_schema.global_variables 
WHERE Variable_name = 'max_connections';
```

#### 1.2 连接详细信息
```sql
-- 查看当前连接详情
SELECT 
    id,
    user,
    host,
    db,
    command,
    time,
    state,
    info
FROM information_schema.processlist
ORDER BY time DESC;

-- 查看连接来源统计
SELECT 
    host,
    COUNT(*) as connection_count
FROM information_schema.processlist
GROUP BY host
ORDER BY connection_count DESC;
```

### 2. 查询性能监控

#### 2.1 查询统计指标
```sql
-- 查看查询统计
SHOW STATUS LIKE 'Questions';
SHOW STATUS LIKE 'Com_select';
SHOW STATUS LIKE 'Com_insert';
SHOW STATUS LIKE 'Com_update';
SHOW STATUS LIKE 'Com_delete';

-- 计算查询QPS
SELECT 
    ROUND(Questions / Uptime, 2) as qps
FROM performance_schema.global_status;
```

#### 2.2 慢查询监控
```sql
-- 查看慢查询数量
SHOW STATUS LIKE 'Slow_queries';

-- 查看慢查询日志
SELECT 
    start_time,
    user_host,
    query_time,
    lock_time,
    rows_sent,
    rows_examined,
    sql_text
FROM mysql.slow_log
WHERE start_time > DATE_SUB(NOW(), INTERVAL 1 HOUR)
ORDER BY query_time DESC;
```

### 3. 缓存监控

#### 3.1 查询缓存监控
```sql
-- 查看查询缓存状态
SHOW STATUS LIKE 'Qcache%';

-- 计算查询缓存命中率
SELECT 
    ROUND(Qcache_hits / (Qcache_hits + Qcache_inserts) * 100, 2) as cache_hit_rate
FROM performance_schema.global_status;
```

#### 3.2 InnoDB缓冲池监控
```sql
-- 查看InnoDB缓冲池状态
SHOW ENGINE INNODB STATUS;

-- 查看缓冲池使用情况
SELECT 
    ROUND(Buffer_pool_pages_data / Buffer_pool_pages_total * 100, 2) as buffer_pool_usage
FROM performance_schema.global_status;
```

### 4. 锁监控

#### 4.1 锁等待监控
```sql
-- 查看当前锁等待
SELECT 
    r.trx_id waiting_trx_id,
    r.trx_mysql_thread_id waiting_thread,
    r.trx_query waiting_query,
    b.trx_id blocking_trx_id,
    b.trx_mysql_thread_id blocking_thread,
    b.trx_query blocking_query
FROM information_schema.innodb_lock_waits w
JOIN information_schema.innodb_trx b ON b.trx_id = w.blocking_trx_id
JOIN information_schema.innodb_trx r ON r.trx_id = w.requesting_trx_id;
```

#### 4.2 死锁监控
```sql
-- 查看死锁次数
SHOW STATUS LIKE 'Innodb_deadlocks';

-- 查看最近死锁信息
SHOW ENGINE INNODB STATUS;
```

## 监控工具

### 1. MySQL 内置监控

#### 1.1 SHOW STATUS 命令
```sql
-- 查看所有状态变量
SHOW STATUS;

-- 查看特定状态变量
SHOW STATUS LIKE 'Threads%';
SHOW STATUS LIKE 'Innodb%';
SHOW STATUS LIKE 'Com%';
```

#### 1.2 SHOW VARIABLES 命令
```sql
-- 查看所有配置变量
SHOW VARIABLES;

-- 查看特定配置变量
SHOW VARIABLES LIKE 'max_connections';
SHOW VARIABLES LIKE 'innodb_buffer_pool_size';
```

#### 1.3 SHOW PROCESSLIST 命令
```sql
-- 查看当前进程列表
SHOW PROCESSLIST;

-- 查看详细信息
SHOW FULL PROCESSLIST;
```

### 2. Performance Schema

#### 2.1 启用Performance Schema
```sql
-- 检查Performance Schema状态
SHOW VARIABLES LIKE 'performance_schema';

-- 启用Performance Schema
UPDATE performance_schema.setup_instruments 
SET ENABLED = 'YES', TIMED = 'YES';

UPDATE performance_schema.setup_consumers 
SET ENABLED = 'YES';
```

#### 2.2 监控查询性能
```sql
-- 查看查询统计
SELECT 
    event_name,
    count_star,
    sum_timer_wait/1000000000 as total_time_sec,
    avg_timer_wait/1000000 as avg_time_ms
FROM performance_schema.events_statements_summary_global_by_event_name
WHERE event_name LIKE 'statement/sql/%'
ORDER BY sum_timer_wait DESC;
```

#### 2.3 监控表访问
```sql
-- 查看表访问统计
SELECT 
    object_schema,
    object_name,
    count_star,
    sum_timer_wait/1000000000 as total_time_sec
FROM performance_schema.table_io_waits_summary_by_table
ORDER BY sum_timer_wait DESC;
```

### 3. 第三方监控工具

#### 3.1 MySQL Workbench
```sql
-- 使用MySQL Workbench的Server Status面板
-- 查看实时性能指标
-- 监控连接、查询、缓存等状态
```

#### 3.2 Percona Monitoring and Management (PMM)
```bash
# 安装PMM客户端
wget https://www.percona.com/downloads/pmm2/2.15.1/binary/tarball/pmm2-client-2.15.1.tar.gz
tar -xzf pmm2-client-2.15.1.tar.gz
cd pmm2-client-2.15.1
./install

# 添加MySQL实例到PMM
pmm-admin add mysql --username=root --password=password --host=localhost --port=3306
```

#### 3.3 Prometheus + Grafana
```yaml
# prometheus.yml 配置
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'mysql'
    static_configs:
      - targets: ['localhost:9104']
```

## 性能分析

### 1. 查询分析

#### 1.1 EXPLAIN 分析
```sql
-- 分析查询执行计划
EXPLAIN SELECT * FROM users WHERE age > 25;

-- 详细分析
EXPLAIN FORMAT=JSON SELECT * FROM users WHERE age > 25;

-- 分析查询成本
EXPLAIN ANALYZE SELECT * FROM users WHERE age > 25;
```

#### 1.2 查询优化建议
```sql
-- 查看未使用索引的查询
SELECT 
    table_schema,
    table_name,
    index_name,
    cardinality
FROM information_schema.statistics
WHERE table_schema = 'your_database'
ORDER BY cardinality DESC;
```

### 2. 索引分析

#### 2.1 索引使用情况
```sql
-- 查看索引使用统计
SELECT 
    object_schema,
    object_name,
    index_name,
    count_star,
    sum_timer_wait/1000000000 as total_time_sec
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE object_schema = 'your_database'
ORDER BY sum_timer_wait DESC;
```

#### 2.2 索引效率分析
```sql
-- 查看索引基数
SELECT 
    table_name,
    index_name,
    cardinality
FROM information_schema.statistics
WHERE table_schema = 'your_database'
ORDER BY cardinality DESC;
```

### 3. 资源使用分析

#### 3.1 内存使用分析
```sql
-- 查看内存使用情况
SELECT 
    variable_name,
    variable_value
FROM performance_schema.global_variables
WHERE variable_name LIKE '%buffer%' OR variable_name LIKE '%cache%';

-- 查看InnoDB缓冲池状态
SHOW ENGINE INNODB STATUS;
```

#### 3.2 磁盘I/O分析
```sql
-- 查看磁盘I/O统计
SHOW STATUS LIKE 'Innodb_buffer_pool_reads';
SHOW STATUS LIKE 'Innodb_buffer_pool_read_requests';

-- 计算缓冲池命中率
SELECT 
    ROUND((1 - Innodb_buffer_pool_reads / Innodb_buffer_pool_read_requests) * 100, 2) as buffer_pool_hit_rate
FROM performance_schema.global_status;
```

## 监控脚本

### 1. 基础监控脚本

#### 1.1 连接监控脚本
```bash
#!/bin/bash
# mysql_connection_monitor.sh

MYSQL_USER="root"
MYSQL_PASS="password"
MYSQL_HOST="localhost"
MYSQL_PORT="3306"

# 获取连接信息
CONNECTIONS=$(mysql -u$MYSQL_USER -p$MYSQL_PASS -h$MYSQL_HOST -P$MYSQL_PORT -e "SHOW STATUS LIKE 'Threads_connected';" -s -N | awk '{print $2}')
MAX_CONNECTIONS=$(mysql -u$MYSQL_USER -p$MYSQL_PASS -h$MYSQL_HOST -P$MYSQL_PORT -e "SHOW VARIABLES LIKE 'max_connections';" -s -N | awk '{print $2}')

# 计算连接使用率
USAGE_PERCENT=$(echo "scale=2; $CONNECTIONS * 100 / $MAX_CONNECTIONS" | bc)

echo "当前连接数: $CONNECTIONS"
echo "最大连接数: $MAX_CONNECTIONS"
echo "连接使用率: $USAGE_PERCENT%"

# 告警阈值检查
if [ $(echo "$USAGE_PERCENT > 80" | bc) -eq 1 ]; then
    echo "警告: 连接使用率超过80%"
fi
```

#### 1.2 性能监控脚本
```bash
#!/bin/bash
# mysql_performance_monitor.sh

MYSQL_USER="root"
MYSQL_PASS="password"
MYSQL_HOST="localhost"
MYSQL_PORT="3306"

# 获取性能指标
QPS=$(mysql -u$MYSQL_USER -p$MYSQL_PASS -h$MYSQL_HOST -P$MYSQL_PORT -e "
SELECT ROUND(Questions / Uptime, 2) as qps 
FROM performance_schema.global_status 
WHERE Variable_name = 'Questions';" -s -N)

SLOW_QUERIES=$(mysql -u$MYSQL_USER -p$MYSQL_PASS -h$MYSQL_HOST -P$MYSQL_PORT -e "SHOW STATUS LIKE 'Slow_queries';" -s -N | awk '{print $2}')

BUFFER_POOL_HIT_RATE=$(mysql -u$MYSQL_USER -p$MYSQL_PASS -h$MYSQL_HOST -P$MYSQL_PORT -e "
SELECT ROUND((1 - Innodb_buffer_pool_reads / Innodb_buffer_pool_read_requests) * 100, 2) as hit_rate
FROM performance_schema.global_status;" -s -N)

echo "QPS: $QPS"
echo "慢查询数: $SLOW_QUERIES"
echo "缓冲池命中率: $BUFFER_POOL_HIT_RATE%"
```

### 2. 高级监控脚本

#### 2.1 实时监控脚本
```python
#!/usr/bin/env python3
# mysql_realtime_monitor.py

import mysql.connector
import time
import datetime

def get_mysql_connection():
    return mysql.connector.connect(
        host="localhost",
        user="root",
        password="password",
        database="mysql"
    )

def get_performance_metrics(cursor):
    # 获取连接信息
    cursor.execute("SHOW STATUS LIKE 'Threads_connected'")
    connections = cursor.fetchone()[1]
    
    # 获取QPS
    cursor.execute("""
        SELECT ROUND(Questions / Uptime, 2) as qps 
        FROM performance_schema.global_status 
        WHERE Variable_name = 'Questions'
    """)
    qps = cursor.fetchone()[0]
    
    # 获取慢查询数
    cursor.execute("SHOW STATUS LIKE 'Slow_queries'")
    slow_queries = cursor.fetchone()[1]
    
    return {
        'connections': connections,
        'qps': qps,
        'slow_queries': slow_queries,
        'timestamp': datetime.datetime.now()
    }

def main():
    conn = get_mysql_connection()
    cursor = conn.cursor()
    
    while True:
        try:
            metrics = get_performance_metrics(cursor)
            print(f"[{metrics['timestamp']}] 连接数: {metrics['connections']}, QPS: {metrics['qps']}, 慢查询: {metrics['slow_queries']}")
            time.sleep(5)
        except Exception as e:
            print(f"监控错误: {e}")
            break
    
    cursor.close()
    conn.close()

if __name__ == "__main__":
    main()
```

## 告警机制

### 1. 告警阈值设置

#### 1.1 连接告警
```sql
-- 连接数告警阈值
SET @max_connections_threshold = 80; -- 80%

-- 检查连接使用率
SELECT 
    CASE 
        WHEN (Threads_connected / max_connections * 100) > @max_connections_threshold 
        THEN 'WARNING: High connection usage'
        ELSE 'OK'
    END as connection_alert
FROM performance_schema.global_status 
JOIN performance_schema.global_variables 
WHERE Variable_name = 'max_connections';
```

#### 1.2 性能告警
```sql
-- 慢查询告警
SELECT 
    CASE 
        WHEN Slow_queries > 10 
        THEN 'WARNING: Too many slow queries'
        ELSE 'OK'
    END as slow_query_alert
FROM performance_schema.global_status 
WHERE Variable_name = 'Slow_queries';
```

### 2. 告警通知

#### 2.1 邮件告警脚本
```bash
#!/bin/bash
# mysql_alert.sh

# 检查连接数
CONNECTIONS=$(mysql -uroot -ppassword -e "SHOW STATUS LIKE 'Threads_connected';" -s -N | awk '{print $2}')
MAX_CONNECTIONS=$(mysql -uroot -ppassword -e "SHOW VARIABLES LIKE 'max_connections';" -s -N | awk '{print $2}')
USAGE_PERCENT=$(echo "scale=2; $CONNECTIONS * 100 / $MAX_CONNECTIONS" | bc)

if [ $(echo "$USAGE_PERCENT > 80" | bc) -eq 1 ]; then
    echo "MySQL连接使用率过高: $USAGE_PERCENT%" | mail -s "MySQL告警" admin@example.com
fi
```

#### 2.2 钉钉告警脚本
```python
#!/usr/bin/env python3
# dingtalk_alert.py

import requests
import json

def send_dingtalk_alert(message, webhook_url):
    headers = {'Content-Type': 'application/json'}
    data = {
        "msgtype": "text",
        "text": {
            "content": f"MySQL告警: {message}"
        }
    }
    
    response = requests.post(webhook_url, headers=headers, data=json.dumps(data))
    return response.status_code == 200

# 使用示例
webhook_url = "https://oapi.dingtalk.com/robot/send?access_token=your_token"
send_dingtalk_alert("连接数过高", webhook_url)
```

## 监控最佳实践

### 1. 监控策略

#### 1.1 分层监控
- **系统层**：CPU、内存、磁盘、网络
- **数据库层**：连接、查询、缓存、锁
- **应用层**：响应时间、错误率、吞吐量

#### 1.2 监控频率
- **实时监控**：每秒或每5秒
- **短期监控**：每分钟
- **长期监控**：每小时或每天

### 2. 性能基准

#### 2.1 建立性能基准
```sql
-- 记录基准性能指标
CREATE TABLE performance_baseline (
    id INT AUTO_INCREMENT PRIMARY KEY,
    metric_name VARCHAR(50),
    metric_value DECIMAL(10,2),
    recorded_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 插入基准数据
INSERT INTO performance_baseline (metric_name, metric_value)
SELECT 'qps', ROUND(Questions / Uptime, 2)
FROM performance_schema.global_status 
WHERE Variable_name = 'Questions';
```

#### 2.2 性能趋势分析
```sql
-- 分析性能趋势
SELECT 
    DATE(recorded_at) as date,
    AVG(metric_value) as avg_value,
    MAX(metric_value) as max_value,
    MIN(metric_value) as min_value
FROM performance_baseline
WHERE metric_name = 'qps'
GROUP BY DATE(recorded_at)
ORDER BY date DESC;
```

### 3. 监控报告

#### 3.1 日常监控报告
```sql
-- 生成日常监控报告
SELECT 
    '连接数' as metric,
    Threads_connected as current_value,
    max_connections as max_value,
    ROUND(Threads_connected / max_connections * 100, 2) as usage_percent
FROM performance_schema.global_status 
JOIN performance_schema.global_variables 
WHERE Variable_name = 'max_connections'

UNION ALL

SELECT 
    'QPS' as metric,
    ROUND(Questions / Uptime, 2) as current_value,
    NULL as max_value,
    NULL as usage_percent
FROM performance_schema.global_status 
WHERE Variable_name = 'Questions'

UNION ALL

SELECT 
    '慢查询数' as metric,
    Slow_queries as current_value,
    NULL as max_value,
    NULL as usage_percent
FROM performance_schema.global_status 
WHERE Variable_name = 'Slow_queries';
```

## 总结

MySQL性能监控是一个持续的过程，需要结合多种工具和方法：

1. **建立完善的监控体系**：使用多种监控工具和指标
2. **设置合理的告警阈值**：避免误报和漏报
3. **定期分析性能趋势**：识别性能瓶颈和优化机会
4. **建立性能基准**：为性能优化提供参考
5. **自动化监控流程**：减少人工干预，提高监控效率

通过以上监控措施，可以确保MySQL数据库的稳定运行和最佳性能。 