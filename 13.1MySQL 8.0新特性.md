# MySQL 8.0 新特性

## 概述

MySQL 8.0 是MySQL数据库的一个重要版本，引入了许多新特性和改进，包括窗口函数、公用表表达式(CTE)、JSON增强、角色管理、原子DDL等。这些新特性大大提升了MySQL的功能性和性能，使其更适合现代应用开发的需求。

## 窗口函数

### 1. 基本概念

#### 1.1 窗口函数介绍
窗口函数允许在查询结果集的特定"窗口"上执行计算，而不影响查询的行数。窗口函数可以访问当前行及其前后行的数据。

#### 1.2 语法结构
```sql
window_function(expression) OVER (
    [PARTITION BY partition_expression, ...]
    [ORDER BY sort_expression [ASC|DESC], ...]
    [frame_clause]
)
```

### 2. 常用窗口函数

#### 2.1 排名函数
```sql
-- ROW_NUMBER(): 为结果集的每一行分配唯一的序号
SELECT 
    name,
    salary,
    ROW_NUMBER() OVER (ORDER BY salary DESC) as row_num
FROM employees;

-- RANK(): 为相同值的行分配相同的排名，跳过重复的排名
SELECT 
    name,
    salary,
    RANK() OVER (ORDER BY salary DESC) as rank_num
FROM employees;

-- DENSE_RANK(): 为相同值的行分配相同的排名，不跳过排名
SELECT 
    name,
    salary,
    DENSE_RANK() OVER (ORDER BY salary DESC) as dense_rank_num
FROM employees;

-- NTILE(n): 将结果集分成n个桶，为每个桶分配桶号
SELECT 
    name,
    salary,
    NTILE(4) OVER (ORDER BY salary DESC) as quartile
FROM employees;
```

#### 2.2 聚合函数
```sql
-- 计算累计和
SELECT 
    date,
    sales,
    SUM(sales) OVER (ORDER BY date) as cumulative_sales
FROM sales_data;

-- 计算移动平均
SELECT 
    date,
    sales,
    AVG(sales) OVER (
        ORDER BY date 
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) as moving_avg_3
FROM sales_data;

-- 计算部门内排名
SELECT 
    name,
    department,
    salary,
    RANK() OVER (PARTITION BY department ORDER BY salary DESC) as dept_rank
FROM employees;
```

#### 2.3 偏移函数
```sql
-- LAG(): 访问当前行之前的数据
SELECT 
    date,
    sales,
    LAG(sales, 1) OVER (ORDER BY date) as prev_sales,
    sales - LAG(sales, 1) OVER (ORDER BY date) as sales_change
FROM sales_data;

-- LEAD(): 访问当前行之后的数据
SELECT 
    date,
    sales,
    LEAD(sales, 1) OVER (ORDER BY date) as next_sales
FROM sales_data;

-- FIRST_VALUE(): 获取窗口中的第一个值
SELECT 
    name,
    department,
    salary,
    FIRST_VALUE(salary) OVER (
        PARTITION BY department 
        ORDER BY salary DESC
    ) as dept_max_salary
FROM employees;
```

### 3. 高级窗口函数

#### 3.1 自定义窗口框架
```sql
-- 定义窗口框架
SELECT 
    date,
    sales,
    SUM(sales) OVER (
        ORDER BY date 
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) as cumulative_sales,
    SUM(sales) OVER (
        ORDER BY date 
        ROWS BETWEEN 2 PRECEDING AND 1 FOLLOWING
    ) as moving_sum
FROM sales_data;
```

#### 3.2 多列分区
```sql
-- 按多个列分区
SELECT 
    name,
    department,
    location,
    salary,
    RANK() OVER (
        PARTITION BY department, location 
        ORDER BY salary DESC
    ) as local_rank
FROM employees;
```

## 公用表表达式 (CTE)

### 1. 基本CTE

#### 1.1 简单CTE
```sql
-- 基本CTE语法
WITH cte_name AS (
    SELECT column1, column2
    FROM table_name
    WHERE condition
)
SELECT * FROM cte_name;

-- 示例：计算部门平均工资
WITH dept_avg AS (
    SELECT 
        department,
        AVG(salary) as avg_salary
    FROM employees
    GROUP BY department
)
SELECT 
    e.name,
    e.department,
    e.salary,
    d.avg_salary,
    e.salary - d.avg_salary as diff_from_avg
FROM employees e
JOIN dept_avg d ON e.department = d.department;
```

#### 1.2 多个CTE
```sql
-- 定义多个CTE
WITH 
dept_stats AS (
    SELECT 
        department,
        COUNT(*) as emp_count,
        AVG(salary) as avg_salary
    FROM employees
    GROUP BY department
),
high_paid_depts AS (
    SELECT department
    FROM dept_stats
    WHERE avg_salary > 50000
)
SELECT 
    e.name,
    e.department,
    e.salary
FROM employees e
JOIN high_paid_depts h ON e.department = h.department;
```

### 2. 递归CTE

#### 2.1 基本递归CTE
```sql
-- 递归CTE语法
WITH RECURSIVE cte_name AS (
    -- 基础查询
    SELECT ...
    FROM table_name
    WHERE condition
    
    UNION ALL
    
    -- 递归查询
    SELECT ...
    FROM table_name t
    JOIN cte_name c ON ...
    WHERE condition
)
SELECT * FROM cte_name;

-- 示例：生成数字序列
WITH RECURSIVE numbers AS (
    SELECT 1 as n
    UNION ALL
    SELECT n + 1
    FROM numbers
    WHERE n < 10
)
SELECT * FROM numbers;
```

#### 2.2 层次数据查询
```sql
-- 查询组织层次结构
WITH RECURSIVE org_hierarchy AS (
    -- 基础查询：查找根节点
    SELECT 
        id,
        name,
        manager_id,
        0 as level,
        CAST(name AS CHAR(1000)) as path
    FROM employees
    WHERE manager_id IS NULL
    
    UNION ALL
    
    -- 递归查询：查找子节点
    SELECT 
        e.id,
        e.name,
        e.manager_id,
        h.level + 1,
        CONCAT(h.path, ' > ', e.name)
    FROM employees e
    JOIN org_hierarchy h ON e.manager_id = h.id
)
SELECT * FROM org_hierarchy
ORDER BY path;
```

### 3. CTE的高级用法

#### 3.1 数据清理和转换
```sql
-- 使用CTE进行数据清理
WITH cleaned_data AS (
    SELECT 
        id,
        TRIM(name) as name,
        CASE 
            WHEN salary < 0 THEN 0
            WHEN salary > 1000000 THEN 1000000
            ELSE salary
        END as salary
    FROM employees
),
valid_data AS (
    SELECT *
    FROM cleaned_data
    WHERE name IS NOT NULL 
    AND LENGTH(name) > 0
)
SELECT * FROM valid_data;
```

#### 3.2 复杂分析查询
```sql
-- 使用CTE进行复杂分析
WITH 
monthly_sales AS (
    SELECT 
        DATE_FORMAT(sale_date, '%Y-%m') as month,
        SUM(amount) as total_sales
    FROM sales
    GROUP BY DATE_FORMAT(sale_date, '%Y-%m')
),
sales_growth AS (
    SELECT 
        month,
        total_sales,
        LAG(total_sales) OVER (ORDER BY month) as prev_month_sales,
        ((total_sales - LAG(total_sales) OVER (ORDER BY month)) / 
         LAG(total_sales) OVER (ORDER BY month)) * 100 as growth_percent
    FROM monthly_sales
)
SELECT 
    month,
    total_sales,
    growth_percent
FROM sales_growth
WHERE growth_percent IS NOT NULL
ORDER BY month;
```

## JSON增强

### 1. JSON函数

#### 1.1 JSON创建函数
```sql
-- JSON_OBJECT(): 创建JSON对象
SELECT JSON_OBJECT(
    'name', name,
    'age', age,
    'salary', salary
) as employee_json
FROM employees;

-- JSON_ARRAY(): 创建JSON数组
SELECT JSON_ARRAY(name, age, salary) as employee_array
FROM employees;

-- JSON_MERGE(): 合并JSON文档
SELECT JSON_MERGE(
    '{"name": "John"}',
    '{"age": 30}',
    '{"department": "IT"}'
) as merged_json;
```

#### 1.2 JSON查询函数
```sql
-- JSON_EXTRACT(): 提取JSON值
SELECT 
    JSON_EXTRACT(employee_data, '$.name') as name,
    JSON_EXTRACT(employee_data, '$.age') as age
FROM employees_json;

-- 使用 -> 操作符（简写）
SELECT 
    employee_data->'$.name' as name,
    employee_data->'$.age' as age
FROM employees_json;

-- JSON_CONTAINS(): 检查JSON是否包含特定值
SELECT *
FROM employees_json
WHERE JSON_CONTAINS(employee_data, '"IT"', '$.department');
```

#### 1.3 JSON修改函数
```sql
-- JSON_SET(): 设置JSON值
UPDATE employees_json
SET employee_data = JSON_SET(
    employee_data,
    '$.salary', salary * 1.1,
    '$.last_updated', NOW()
)
WHERE JSON_EXTRACT(employee_data, '$.department') = 'IT';

-- JSON_REMOVE(): 删除JSON值
UPDATE employees_json
SET employee_data = JSON_REMOVE(employee_data, '$.temp_field');

-- JSON_REPLACE(): 替换JSON值
UPDATE employees_json
SET employee_data = JSON_REPLACE(
    employee_data,
    '$.department',
    'Engineering'
)
WHERE JSON_EXTRACT(employee_data, '$.id') = 1;
```

### 2. JSON索引

#### 2.1 函数索引
```sql
-- 在JSON字段上创建函数索引
CREATE INDEX idx_employee_name 
ON employees_json ((JSON_EXTRACT(employee_data, '$.name')));

-- 在JSON数组上创建索引
CREATE INDEX idx_employee_skills 
ON employees_json ((JSON_EXTRACT(employee_data, '$.skills')));
```

#### 2.2 多值索引
```sql
-- 创建多值索引
CREATE INDEX idx_employee_skills_multi 
ON employees_json ((CAST(JSON_EXTRACT(employee_data, '$.skills') AS CHAR(100)));
```

### 3. JSON验证

#### 3.1 JSON_SCHEMA_VALID()
```sql
-- 验证JSON是否符合模式
SELECT 
    id,
    JSON_SCHEMA_VALID(
        '{
            "type": "object",
            "properties": {
                "name": {"type": "string"},
                "age": {"type": "integer", "minimum": 0}
            },
            "required": ["name", "age"]
        }',
        employee_data
    ) as is_valid
FROM employees_json;
```

## 角色管理

### 1. 角色创建和管理

#### 1.1 创建角色
```sql
-- 创建角色
CREATE ROLE 'app_developer', 'app_readonly', 'app_admin';

-- 为角色授予权限
GRANT SELECT, INSERT, UPDATE, DELETE ON app_db.* TO 'app_developer';
GRANT SELECT ON app_db.* TO 'app_readonly';
GRANT ALL PRIVILEGES ON app_db.* TO 'app_admin';
```

#### 1.2 角色分配
```sql
-- 将角色授予用户
GRANT 'app_developer' TO 'developer1'@'localhost';
GRANT 'app_readonly' TO 'analyst1'@'localhost';
GRANT 'app_admin' TO 'admin1'@'localhost';

-- 设置默认角色
SET DEFAULT ROLE 'app_developer' TO 'developer1'@'localhost';
```

### 2. 角色权限管理

#### 2.1 查看角色权限
```sql
-- 查看角色权限
SHOW GRANTS FOR 'app_developer';

-- 查看用户角色
SHOW GRANTS FOR 'developer1'@'localhost';

-- 查看当前用户角色
SELECT CURRENT_ROLE();
```

#### 2.2 角色权限修改
```sql
-- 修改角色权限
REVOKE DELETE ON app_db.* FROM 'app_developer';
GRANT CREATE, DROP ON app_db.* TO 'app_developer';

-- 撤销用户角色
REVOKE 'app_developer' FROM 'developer1'@'localhost';
```

### 3. 角色继承

#### 3.1 角色层次结构
```sql
-- 创建层次化角色
CREATE ROLE 'senior_developer';
GRANT 'app_developer' TO 'senior_developer';
GRANT CREATE, DROP, ALTER ON app_db.* TO 'senior_developer';

-- 将高级角色授予用户
GRANT 'senior_developer' TO 'senior_dev1'@'localhost';
```

## 原子DDL

### 1. 原子DDL特性

#### 1.1 支持的DDL操作
```sql
-- 原子CREATE TABLE
CREATE TABLE test_table (
    id INT PRIMARY KEY,
    name VARCHAR(50)
);

-- 原子ALTER TABLE
ALTER TABLE test_table 
ADD COLUMN email VARCHAR(100),
ADD INDEX idx_email (email);

-- 原子DROP TABLE
DROP TABLE test_table;
```

#### 1.2 事务中的DDL
```sql
-- 在事务中执行DDL
START TRANSACTION;

CREATE TABLE temp_table1 (id INT);
CREATE TABLE temp_table2 (id INT);

-- 如果任何DDL失败，所有操作都会回滚
COMMIT;
```

### 2. 数据字典

#### 2.1 系统表
```sql
-- 查看数据字典表
SELECT * FROM information_schema.tables 
WHERE table_schema = 'mysql';

-- 查看表结构信息
SELECT 
    table_name,
    table_type,
    engine,
    table_rows,
    avg_row_length,
    data_length,
    max_data_length,
    index_length,
    data_free,
    auto_increment,
    create_time,
    update_time,
    check_time,
    table_collation,
    checksum,
    create_options,
    table_comment
FROM information_schema.tables
WHERE table_schema = 'your_database';
```

## 其他新特性

### 1. 不可见索引

#### 1.1 创建不可见索引
```sql
-- 创建不可见索引
CREATE INDEX idx_invisible ON employees (email) INVISIBLE;

-- 查看不可见索引
SELECT 
    index_name,
    is_visible
FROM information_schema.statistics
WHERE table_schema = 'your_database'
AND table_name = 'employees';
```

#### 1.2 管理不可见索引
```sql
-- 使索引可见
ALTER TABLE employees ALTER INDEX idx_invisible VISIBLE;

-- 使索引不可见
ALTER TABLE employees ALTER INDEX idx_invisible INVISIBLE;

-- 删除不可见索引
DROP INDEX idx_invisible ON employees;
```

### 2. 降序索引

#### 2.1 创建降序索引
```sql
-- 创建降序索引
CREATE INDEX idx_desc ON employees (salary DESC, hire_date ASC);

-- 在复合索引中使用降序
CREATE INDEX idx_multi_desc ON employees (
    department ASC,
    salary DESC,
    hire_date ASC
);
```

### 3. 函数索引

#### 3.1 创建函数索引
```sql
-- 创建函数索引
CREATE INDEX idx_upper_name ON employees ((UPPER(name)));

-- 创建表达式索引
CREATE INDEX idx_salary_range ON employees ((salary / 1000));

-- 在JSON字段上创建函数索引
CREATE INDEX idx_json_name ON employees_json ((JSON_EXTRACT(employee_data, '$.name')));
```

### 4. 通用表表达式优化

#### 4.1 CTE优化
```sql
-- 使用CTE进行递归查询优化
WITH RECURSIVE employee_hierarchy AS (
    SELECT 
        id,
        name,
        manager_id,
        0 as level
    FROM employees
    WHERE manager_id IS NULL
    
    UNION ALL
    
    SELECT 
        e.id,
        e.name,
        e.manager_id,
        h.level + 1
    FROM employees e
    JOIN employee_hierarchy h ON e.manager_id = h.id
)
SELECT * FROM employee_hierarchy;
```

## 性能改进

### 1. 查询优化器改进

#### 1.1 成本模型改进
```sql
-- 查看查询执行计划
EXPLAIN FORMAT=JSON
SELECT e.name, d.department_name
FROM employees e
JOIN departments d ON e.department_id = d.id
WHERE e.salary > 50000;
```

#### 1.2 直方图统计
```sql
-- 创建直方图统计
ANALYZE TABLE employees UPDATE HISTOGRAM ON salary, age;

-- 查看直方图信息
SELECT * FROM information_schema.column_statistics
WHERE table_schema = 'your_database'
AND table_name = 'employees';
```

### 2. 并行查询

#### 2.1 并行查询配置
```sql
-- 设置并行查询参数
SET SESSION innodb_parallel_read_threads = 4;
SET SESSION innodb_parallel_write_threads = 4;

-- 查看并行查询状态
SHOW VARIABLES LIKE 'innodb_parallel%';
```

## 安全改进

### 1. 密码策略

#### 1.1 密码验证插件
```sql
-- 安装密码验证插件
INSTALL PLUGIN validate_password SONAME 'validate_password.so';

-- 配置密码策略
SET GLOBAL validate_password.policy = MEDIUM;
SET GLOBAL validate_password.length = 8;
SET GLOBAL validate_password.mixed_case_count = 1;
SET GLOBAL validate_password.number_count = 1;
SET GLOBAL validate_password.special_char_count = 1;
```

#### 1.2 密码过期
```sql
-- 设置密码过期策略
ALTER USER 'user1'@'localhost' PASSWORD EXPIRE INTERVAL 90 DAY;

-- 设置全局密码过期
SET GLOBAL default_password_lifetime = 90;
```

### 2. 加密改进

#### 2.1 表空间加密
```sql
-- 创建加密表空间
CREATE TABLESPACE encrypted_tablespace
ADD DATAFILE 'encrypted_tablespace.ibd'
ENCRYPTION='Y';

-- 在加密表空间中创建表
CREATE TABLE encrypted_table (
    id INT PRIMARY KEY,
    data VARCHAR(255)
) TABLESPACE encrypted_tablespace;
```

## 总结

MySQL 8.0的新特性大大提升了数据库的功能性和性能：

1. **窗口函数**：提供了强大的分析查询能力
2. **CTE**：简化了复杂查询的编写
3. **JSON增强**：原生支持JSON数据类型和操作
4. **角色管理**：提供了更灵活的权限管理
5. **原子DDL**：提高了DDL操作的可靠性
6. **性能改进**：优化了查询执行和索引管理
7. **安全改进**：增强了密码策略和加密功能

这些新特性使MySQL 8.0更适合现代应用开发的需求，提供了更好的性能、安全性和易用性。 

**[返回目录 README.md](./README?id=_13-mysql-版本特性)** 