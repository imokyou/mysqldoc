# MySQL 5.7 特性

## 概述

MySQL 5.7 是MySQL数据库的一个重要版本，引入了许多新特性和改进，包括JSON数据类型、Generated Columns、InnoDB增强、复制增强等。这些特性为MySQL提供了更强大的功能和更好的性能，为后续版本的发展奠定了基础。

## JSON数据类型

### 1. JSON基础

#### 1.1 JSON数据类型介绍
MySQL 5.7引入了原生JSON数据类型，支持存储和操作JSON格式的数据，提供了丰富的JSON函数和操作符。

#### 1.2 创建JSON列
```sql
-- 创建包含JSON列的表
CREATE TABLE employees (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100),
    info JSON,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 插入JSON数据
INSERT INTO employees (name, info) VALUES 
('John Doe', '{"age": 30, "department": "IT", "skills": ["Java", "Python"]}'),
('Jane Smith', '{"age": 25, "department": "HR", "skills": ["Communication", "Organization"]}');
```

### 2. JSON函数

#### 2.1 JSON创建函数
```sql
-- JSON_OBJECT(): 创建JSON对象
SELECT JSON_OBJECT('name', name, 'age', 30, 'active', true) as employee_json
FROM employees;

-- JSON_ARRAY(): 创建JSON数组
SELECT JSON_ARRAY('John', 30, 'IT') as employee_array;

-- JSON_MERGE(): 合并JSON文档
SELECT JSON_MERGE(
    '{"name": "John"}',
    '{"age": 30}',
    '{"department": "IT"}'
) as merged_json;
```

#### 2.2 JSON查询函数
```sql
-- JSON_EXTRACT(): 提取JSON值
SELECT 
    name,
    JSON_EXTRACT(info, '$.age') as age,
    JSON_EXTRACT(info, '$.department') as department
FROM employees;

-- 使用 -> 操作符（简写）
SELECT 
    name,
    info->'$.age' as age,
    info->'$.department' as department
FROM employees;

-- JSON_CONTAINS(): 检查JSON是否包含特定值
SELECT *
FROM employees
WHERE JSON_CONTAINS(info, '"IT"', '$.department');

-- JSON_SEARCH(): 搜索JSON中的值
SELECT 
    name,
    JSON_SEARCH(info, 'one', 'Java') as java_skill
FROM employees
WHERE JSON_SEARCH(info, 'one', 'Java') IS NOT NULL;
```

#### 2.3 JSON修改函数
```sql
-- JSON_SET(): 设置JSON值
UPDATE employees
SET info = JSON_SET(info, '$.salary', 50000, '$.last_updated', NOW())
WHERE id = 1;

-- JSON_REPLACE(): 替换JSON值
UPDATE employees
SET info = JSON_REPLACE(info, '$.department', 'Engineering')
WHERE id = 1;

-- JSON_REMOVE(): 删除JSON值
UPDATE employees
SET info = JSON_REMOVE(info, '$.temp_field')
WHERE id = 1;

-- JSON_INSERT(): 插入JSON值
UPDATE employees
SET info = JSON_INSERT(info, '$.location', 'New York')
WHERE id = 1;
```

### 3. JSON索引

#### 3.1 函数索引
```sql
-- 在JSON字段上创建函数索引
CREATE INDEX idx_employee_age 
ON employees ((JSON_EXTRACT(info, '$.age')));

CREATE INDEX idx_employee_department 
ON employees ((JSON_EXTRACT(info, '$.department')));

-- 在JSON数组上创建索引
CREATE INDEX idx_employee_skills 
ON employees ((JSON_EXTRACT(info, '$.skills')));
```

#### 3.2 虚拟列索引
```sql
-- 创建虚拟列
ALTER TABLE employees 
ADD COLUMN age_virtual INT 
GENERATED ALWAYS AS (JSON_EXTRACT(info, '$.age')) VIRTUAL;

-- 在虚拟列上创建索引
CREATE INDEX idx_age_virtual ON employees (age_virtual);
```

## Generated Columns

### 1. 基本概念

#### 1.1 Generated Columns介绍
Generated Columns（生成列）是MySQL 5.7引入的新特性，允许在表中创建基于其他列计算得出的列，支持VIRTUAL（虚拟）和STORED（存储）两种类型。

#### 1.2 语法结构
```sql
column_name data_type 
GENERATED ALWAYS AS (expression) 
[VIRTUAL | STORED]
```

### 2. 虚拟列（VIRTUAL）

#### 2.1 创建虚拟列
```sql
-- 创建包含虚拟列的表
CREATE TABLE products (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100),
    price DECIMAL(10,2),
    tax_rate DECIMAL(4,2) DEFAULT 0.08,
    price_with_tax DECIMAL(10,2) 
        GENERATED ALWAYS AS (price * (1 + tax_rate)) VIRTUAL
);

-- 插入数据
INSERT INTO products (name, price, tax_rate) VALUES 
('Product A', 100.00, 0.08),
('Product B', 200.00, 0.10),
('Product C', 150.00, 0.05);

-- 查询结果
SELECT * FROM products;
```

#### 2.2 虚拟列索引
```sql
-- 在虚拟列上创建索引
CREATE INDEX idx_price_with_tax ON products (price_with_tax);

-- 使用虚拟列进行查询
SELECT * FROM products 
WHERE price_with_tax > 200.00
ORDER BY price_with_tax;
```

### 3. 存储列（STORED）

#### 3.1 创建存储列
```sql
-- 创建包含存储列的表
CREATE TABLE orders (
    id INT PRIMARY KEY AUTO_INCREMENT,
    customer_id INT,
    order_date DATE,
    total_amount DECIMAL(10,2),
    tax_amount DECIMAL(10,2) 
        GENERATED ALWAYS AS (total_amount * 0.08) STORED,
    final_amount DECIMAL(10,2) 
        GENERATED ALWAYS AS (total_amount + tax_amount) STORED
);

-- 插入数据
INSERT INTO orders (customer_id, order_date, total_amount) VALUES 
(1, '2023-01-15', 1000.00),
(2, '2023-01-16', 2500.00),
(3, '2023-01-17', 800.00);
```

#### 3.2 存储列的优势
```sql
-- 存储列的优势：查询性能更好
SELECT 
    customer_id,
    total_amount,
    tax_amount,
    final_amount
FROM orders
WHERE final_amount > 1000.00
ORDER BY final_amount DESC;
```

### 4. 高级用法

#### 4.1 复杂表达式
```sql
-- 使用复杂表达式的生成列
CREATE TABLE employees (
    id INT PRIMARY KEY AUTO_INCREMENT,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    full_name VARCHAR(100) 
        GENERATED ALWAYS AS (CONCAT(first_name, ' ', last_name)) VIRTUAL,
    email VARCHAR(100) 
        GENERATED ALWAYS AS (CONCAT(LOWER(first_name), '.', LOWER(last_name), '@company.com')) VIRTUAL,
    hire_date DATE,
    years_of_service INT 
        GENERATED ALWAYS AS (YEAR(CURDATE()) - YEAR(hire_date)) VIRTUAL
);

-- 插入数据
INSERT INTO employees (first_name, last_name, hire_date) VALUES 
('John', 'Doe', '2018-03-15'),
('Jane', 'Smith', '2020-07-22'),
('Bob', 'Johnson', '2015-11-08');
```

#### 4.2 JSON与生成列结合
```sql
-- JSON与生成列结合使用
CREATE TABLE products (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100),
    attributes JSON,
    category VARCHAR(50) 
        GENERATED ALWAYS AS (JSON_EXTRACT(attributes, '$.category')) VIRTUAL,
    brand VARCHAR(50) 
        GENERATED ALWAYS AS (JSON_EXTRACT(attributes, '$.brand')) VIRTUAL,
    price DECIMAL(10,2) 
        GENERATED ALWAYS AS (JSON_EXTRACT(attributes, '$.price')) VIRTUAL
);

-- 插入数据
INSERT INTO products (name, attributes) VALUES 
('Laptop', '{"category": "Electronics", "brand": "Dell", "price": 999.99}'),
('Phone', '{"category": "Electronics", "brand": "Apple", "price": 699.99}'),
('Book', '{"category": "Books", "brand": "Publisher", "price": 29.99}');
```

## InnoDB增强

### 1. 性能改进

#### 1.1 缓冲池改进
```sql
-- 查看缓冲池状态
SHOW ENGINE INNODB STATUS;

-- 查看缓冲池统计信息
SELECT 
    pool_id,
    pool_size,
    free_buffers,
    database_pages,
    old_database_pages,
    modified_database_pages,
    pending_decompress,
    pending_reads,
    pending_flush_lru,
    pending_flush_list,
    pages_made_young,
    pages_not_made_young,
    pages_read,
    pages_created,
    pages_written,
    pages_read_ahead_rnd,
    pages_read_ahead,
    pages_read_ahead_evicted,
    read_ahead_rnd,
    read_ahead,
    read_ahead_evicted,
    pages_read_ahead_rnd_evicted,
    pages_read_ahead_evicted,
    pages_read_ahead_evicted_rnd,
    pages_read_ahead_evicted_rnd_evicted,
    pages_read_ahead_evicted_rnd_evicted_rnd,
    pages_read_ahead_evicted_rnd_evicted_rnd_evicted,
    pages_read_ahead_evicted_rnd_evicted_rnd_evicted_rnd,
    pages_read_ahead_evicted_rnd_evicted_rnd_evicted_rnd_evicted
FROM information_schema.innodb_buffer_pool_stats;
```

#### 1.2 自适应哈希索引
```sql
-- 查看自适应哈希索引状态
SHOW VARIABLES LIKE 'innodb_adaptive_hash_index';

-- 查看自适应哈希索引统计
SELECT 
    hash_searches,
    non_hash_searches
FROM information_schema.innodb_metrics
WHERE name IN ('adaptive_hash_searches', 'adaptive_hash_searches_btree');
```

### 2. 并发改进

#### 2.1 多线程清理
```sql
-- 配置多线程清理
SET GLOBAL innodb_purge_threads = 4;
SET GLOBAL innodb_purge_batch_size = 300;

-- 查看清理线程状态
SHOW VARIABLES LIKE 'innodb_purge%';
```

#### 2.2 在线DDL改进
```sql
-- 在线添加列
ALTER TABLE employees 
ADD COLUMN email VARCHAR(100) AFTER name,
ALGORITHM=INPLACE,
LOCK=NONE;

-- 在线添加索引
ALTER TABLE employees 
ADD INDEX idx_email (email),
ALGORITHM=INPLACE,
LOCK=NONE;

-- 在线修改列
ALTER TABLE employees 
MODIFY COLUMN email VARCHAR(150),
ALGORITHM=INPLACE,
LOCK=NONE;
```

### 3. 存储改进

#### 3.1 临时表改进
```sql
-- 配置临时表存储
SET GLOBAL internal_tmp_mem_storage_engine = 'TempTable';

-- 查看临时表配置
SHOW VARIABLES LIKE 'internal_tmp%';
```

#### 3.2 表空间管理
```sql
-- 创建独立表空间
CREATE TABLE employees (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100),
    email VARCHAR(100)
) TABLESPACE = innodb_file_per_table;

-- 查看表空间信息
SELECT 
    table_schema,
    table_name,
    tablespace_name
FROM information_schema.tables
WHERE table_schema = 'your_database';
```

## 复制增强

### 1. 多源复制

#### 1.1 配置多源复制
```sql
-- 在从库上配置多源复制
CHANGE MASTER TO
    MASTER_HOST='master1_ip',
    MASTER_USER='repl',
    MASTER_PASSWORD='password',
    MASTER_LOG_FILE='mysql-bin.000001',
    MASTER_LOG_POS=123
FOR CHANNEL 'master1';

CHANGE MASTER TO
    MASTER_HOST='master2_ip',
    MASTER_USER='repl',
    MASTER_PASSWORD='password',
    MASTER_LOG_FILE='mysql-bin.000001',
    MASTER_LOG_POS=456
FOR CHANNEL 'master2';

-- 启动复制
START SLAVE FOR CHANNEL 'master1';
START SLAVE FOR CHANNEL 'master2';
```

#### 1.2 监控多源复制
```sql
-- 查看所有复制通道状态
SHOW SLAVE STATUS\G

-- 查看特定通道状态
SHOW SLAVE STATUS FOR CHANNEL 'master1'\G

-- 查看复制连接状态
SELECT 
    channel_name,
    source_host,
    source_port,
    source_user,
    source_log_file,
    source_log_pos,
    relay_log_file,
    relay_log_pos,
    relay_master_log_file,
    exec_master_log_pos,
    slave_io_running,
    slave_sql_running,
    seconds_behind_source
FROM performance_schema.replication_connection_status;
```

### 2. 基于GTID的复制

#### 2.1 GTID配置
```sql
-- 在主库上启用GTID
SET GLOBAL gtid_mode = ON;
SET GLOBAL enforce_gtid_consistency = ON;

-- 在从库上配置GTID复制
CHANGE MASTER TO
    MASTER_HOST='master_ip',
    MASTER_USER='repl',
    MASTER_PASSWORD='password',
    MASTER_AUTO_POSITION = 1;

-- 启动复制
START SLAVE;
```

#### 2.2 GTID监控
```sql
-- 查看GTID状态
SELECT @@GLOBAL.gtid_executed;

-- 查看GTID集合
SELECT 
    source_uuid,
    interval_start,
    interval_end
FROM mysql.gtid_executed;
```

### 3. 复制过滤

#### 3.1 基于数据库的过滤
```sql
-- 配置复制过滤
CHANGE REPLICATION FILTER REPLICATE_DO_DB = (db1, db2);
CHANGE REPLICATION FILTER REPLICATE_IGNORE_DB = (temp_db);

-- 查看复制过滤配置
SHOW SLAVE STATUS\G
```

#### 3.2 基于表的过滤
```sql
-- 配置表级过滤
CHANGE REPLICATION FILTER REPLICATE_DO_TABLE = (db1.table1, db2.table2);
CHANGE REPLICATION FILTER REPLICATE_IGNORE_TABLE = (db1.temp_table);

-- 使用通配符
CHANGE REPLICATION FILTER REPLICATE_WILD_DO_TABLE = ('db1.%');
CHANGE REPLICATION FILTER REPLICATE_WILD_IGNORE_TABLE = ('db1.temp_%');
```

## 优化器改进

### 1. 查询优化器

#### 1.1 成本模型改进
```sql
-- 查看查询执行计划
EXPLAIN FORMAT=JSON
SELECT e.name, d.department_name
FROM employees e
JOIN departments d ON e.department_id = d.id
WHERE e.salary > 50000;

-- 查看优化器跟踪
SET optimizer_trace = 'enabled=on';
SELECT * FROM employees WHERE salary > 50000;
SELECT * FROM information_schema.optimizer_trace;
SET optimizer_trace = 'enabled=off';
```

#### 1.2 统计信息改进
```sql
-- 更新表统计信息
ANALYZE TABLE employees;

-- 查看表统计信息
SELECT 
    table_name,
    table_rows,
    avg_row_length,
    data_length,
    max_data_length,
    index_length,
    data_free,
    auto_increment,
    create_time,
    update_time,
    check_time,
    table_collation,
    checksum,
    create_options,
    table_comment
FROM information_schema.tables
WHERE table_schema = 'your_database';
```

### 2. 索引改进

#### 2.1 索引统计
```sql
-- 查看索引统计信息
SELECT 
    table_schema,
    table_name,
    index_name,
    cardinality,
    sub_part,
    packed,
    null,
    index_type,
    comment,
    index_comment
FROM information_schema.statistics
WHERE table_schema = 'your_database'
ORDER BY table_name, index_name;
```

#### 2.2 索引使用分析
```sql
-- 查看索引使用情况
SELECT 
    object_schema,
    object_name,
    index_name,
    count_star,
    sum_timer_wait/1000000000 as total_time_sec,
    avg_timer_wait/1000000 as avg_time_ms
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE object_schema = 'your_database'
ORDER BY sum_timer_wait DESC;
```

## 安全改进

### 1. 密码策略

#### 1.1 密码验证插件
```sql
-- 安装密码验证插件
INSTALL PLUGIN validate_password SONAME 'validate_password.so';

-- 配置密码策略
SET GLOBAL validate_password.policy = MEDIUM;
SET GLOBAL validate_password.length = 8;
SET GLOBAL validate_password.mixed_case_count = 1;
SET GLOBAL validate_password.number_count = 1;
SET GLOBAL validate_password.special_char_count = 1;
```

#### 1.2 密码过期
```sql
-- 设置密码过期
ALTER USER 'user1'@'localhost' PASSWORD EXPIRE;

-- 设置密码过期时间
ALTER USER 'user1'@'localhost' PASSWORD EXPIRE INTERVAL 90 DAY;

-- 设置全局密码过期
SET GLOBAL default_password_lifetime = 90;
```

### 2. 连接控制

#### 2.1 连接限制
```sql
-- 安装连接控制插件
INSTALL PLUGIN connection_control SONAME 'connection_control.so';

-- 配置连接控制
SET GLOBAL connection_control_failed_connections_threshold = 3;
SET GLOBAL connection_control_min_connection_delay = 1000;
SET GLOBAL connection_control_max_connection_delay = 2147483647;
```

#### 2.2 连接监控
```sql
-- 查看连接状态
SELECT 
    id,
    user,
    host,
    db,
    command,
    time,
    state,
    info
FROM information_schema.processlist
ORDER BY time DESC;
```

## 监控改进

### 1. Performance Schema

#### 1.1 启用Performance Schema
```sql
-- 启用Performance Schema
UPDATE performance_schema.setup_instruments 
SET ENABLED = 'YES', TIMED = 'YES';

UPDATE performance_schema.setup_consumers 
SET ENABLED = 'YES';
```

#### 1.2 监控查询性能
```sql
-- 查看查询统计
SELECT 
    event_name,
    count_star,
    sum_timer_wait/1000000000 as total_time_sec,
    avg_timer_wait/1000000 as avg_time_ms
FROM performance_schema.events_statements_summary_global_by_event_name
WHERE event_name LIKE 'statement/sql/%'
ORDER BY sum_timer_wait DESC;
```

### 2. 系统变量

#### 2.1 新增系统变量
```sql
-- 查看新增的系统变量
SHOW VARIABLES LIKE 'innodb_buffer_pool_dump%';
SHOW VARIABLES LIKE 'innodb_buffer_pool_load%';
SHOW VARIABLES LIKE 'innodb_buffer_pool_filename%';

-- 配置缓冲池转储
SET GLOBAL innodb_buffer_pool_dump_at_shutdown = ON;
SET GLOBAL innodb_buffer_pool_load_at_startup = ON;
```

## 总结

MySQL 5.7的新特性为数据库提供了更强大的功能：

1. **JSON数据类型**：原生支持JSON存储和操作
2. **Generated Columns**：支持基于表达式的列生成
3. **InnoDB增强**：改进的性能和并发处理
4. **复制增强**：多源复制和GTID支持
5. **优化器改进**：更好的查询优化和统计信息
6. **安全改进**：增强的密码策略和连接控制
7. **监控改进**：更完善的性能监控

这些特性使MySQL 5.7成为一个功能强大、性能优异的数据库版本，为后续版本的发展奠定了坚实的基础。 

**[返回目录 README.md](./README.md)** 