# MySQL 读写分离

## 概述

MySQL读写分离是一种常见的数据库架构优化策略，通过将读操作和写操作分配到不同的数据库服务器上，可以提高系统的整体性能和可扩展性。读写分离可以有效减轻主库的负载，提高查询性能，同时保持数据的一致性。

## 架构模式

### 1. 基本架构

#### 1.1 一主多从架构
```
应用层
    ↓
读写分离中间件
    ↓
├── 主库 (Master) - 写操作
├── 从库1 (Slave1) - 读操作
├── 从库2 (Slave2) - 读操作
└── 从库3 (Slave3) - 读操作
```

#### 1.2 负载均衡架构
```
应用层
    ↓
负载均衡器
    ↓
├── 主库集群 - 写操作
└── 从库集群 - 读操作
```

### 2. 分离策略

#### 2.1 基于SQL类型分离
- **写操作**：INSERT、UPDATE、DELETE、CREATE、DROP、ALTER
- **读操作**：SELECT、SHOW、DESCRIBE、EXPLAIN

#### 2.2 基于事务分离
- **写事务**：包含写操作的事务路由到主库
- **只读事务**：纯查询事务路由到从库

## 应用层分离

### 1. 代码层面实现

#### 1.1 数据源配置
```java
// Java 数据源配置
@Configuration
public class DataSourceConfig {
    
    @Bean
    @Primary
    @ConfigurationProperties("spring.datasource.master")
    public DataSource masterDataSource() {
        return DataSourceBuilder.create().build();
    }
    
    @Bean
    @ConfigurationProperties("spring.datasource.slave")
    public DataSource slaveDataSource() {
        return DataSourceBuilder.create().build();
    }
    
    @Bean
    public DataSourceRouter dataSourceRouter() {
        return new DataSourceRouter(masterDataSource(), slaveDataSource());
    }
}
```

#### 1.2 动态数据源路由
```java
// 动态数据源路由实现
public class DataSourceRouter extends AbstractRoutingDataSource {
    
    private DataSource masterDataSource;
    private DataSource slaveDataSource;
    
    public DataSourceRouter(DataSource masterDataSource, DataSource slaveDataSource) {
        this.masterDataSource = masterDataSource;
        this.slaveDataSource = slaveDataSource;
    }
    
    @Override
    protected Object determineCurrentLookupKey() {
        return DataSourceContextHolder.getDataSourceType();
    }
    
    @Override
    protected DataSource determineTargetDataSource() {
        String dataSourceType = DataSourceContextHolder.getDataSourceType();
        if ("master".equals(dataSourceType)) {
            return masterDataSource;
        } else {
            return slaveDataSource;
        }
    }
}
```

#### 1.3 数据源上下文
```java
// 数据源上下文管理
public class DataSourceContextHolder {
    
    private static final ThreadLocal<String> contextHolder = new ThreadLocal<>();
    
    public static void setDataSourceType(String dataSourceType) {
        contextHolder.set(dataSourceType);
    }
    
    public static String getDataSourceType() {
        return contextHolder.get();
    }
    
    public static void clearDataSourceType() {
        contextHolder.remove();
    }
}
```

### 2. 注解方式实现

#### 2.1 自定义注解
```java
// 数据源注解
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface DataSource {
    String value() default "slave";
}

// 主库注解
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@DataSource("master")
public @interface Master {
}

// 从库注解
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@DataSource("slave")
public @interface Slave {
}
```

#### 2.2 AOP切面实现
```java
// 数据源切换切面
@Aspect
@Component
public class DataSourceAspect {
    
    @Around("@annotation(dataSource)")
    public Object around(ProceedingJoinPoint point, DataSource dataSource) throws Throwable {
        String dataSourceType = dataSource.value();
        DataSourceContextHolder.setDataSourceType(dataSourceType);
        
        try {
            return point.proceed();
        } finally {
            DataSourceContextHolder.clearDataSourceType();
        }
    }
}
```

### 3. 服务层实现

#### 3.1 服务接口
```java
// 用户服务接口
public interface UserService {
    
    @Master
    void createUser(User user);
    
    @Slave
    User getUserById(Long id);
    
    @Master
    void updateUser(User user);
    
    @Slave
    List<User> getAllUsers();
}
```

#### 3.2 服务实现
```java
// 用户服务实现
@Service
public class UserServiceImpl implements UserService {
    
    @Autowired
    private UserMapper userMapper;
    
    @Override
    public void createUser(User user) {
        userMapper.insert(user);
    }
    
    @Override
    public User getUserById(Long id) {
        return userMapper.selectById(id);
    }
    
    @Override
    public void updateUser(User user) {
        userMapper.updateById(user);
    }
    
    @Override
    public List<User> getAllUsers() {
        return userMapper.selectList(null);
    }
}
```

## 代理层分离

### 1. MySQL Router

#### 1.1 基础配置
```ini
# MySQL Router 配置文件
[DEFAULT]
user=mysqlrouter
keyring_path=/var/lib/mysqlrouter/keyring

[metadata_cache:prod]
router_id=1
bootstrap_server_addresses=192.168.1.10:3306,192.168.1.11:3306,192.168.1.12:3306
user=mysqlrouter
metadata_cluster=prod

[routing:read_write]
bind_address=0.0.0.0
bind_port=6446
destinations=metadata-cache://prod/?role=PRIMARY
routing_strategy=first-available

[routing:read_only]
bind_address=0.0.0.0
bind_port=6447
destinations=metadata-cache://prod/?role=SECONDARY
routing_strategy=round-robin
```

#### 1.2 启动和监控
```bash
# 启动MySQL Router
mysqlrouter --config /etc/mysqlrouter/mysqlrouter.conf

# 检查Router状态
mysqlrouter --config /etc/mysqlrouter/mysqlrouter.conf --help

# 查看Router日志
tail -f /var/log/mysqlrouter/mysqlrouter.log
```

### 2. ProxySQL

#### 2.1 基础配置
```sql
-- 配置服务器
INSERT INTO mysql_servers (hostgroup_id, hostname, port) VALUES
(10, '192.168.1.10', 3306),  -- 主库
(20, '192.168.1.11', 3306),  -- 从库1
(20, '192.168.1.12', 3306);  -- 从库2

-- 配置用户
INSERT INTO mysql_users (username, password, default_hostgroup) VALUES
('app_user', 'password', 10);

-- 配置查询规则
INSERT INTO mysql_query_rules (rule_id, active, match_pattern, destination_hostgroup) VALUES
(1, 1, '^SELECT', 20),           -- SELECT查询路由到从库
(2, 1, '^INSERT|^UPDATE|^DELETE', 10);  -- 写操作路由到主库

-- 加载配置
LOAD MYSQL SERVERS TO RUNTIME;
LOAD MYSQL USERS TO RUNTIME;
LOAD MYSQL QUERY RULES TO RUNTIME;
SAVE MYSQL SERVERS TO MEMORY;
SAVE MYSQL USERS TO MEMORY;
SAVE MYSQL QUERY RULES TO MEMORY;
```

#### 2.2 高级配置
```sql
-- 配置连接池
UPDATE mysql_servers SET max_connections=100, max_replication_lag=30;

-- 配置读写分离规则
INSERT INTO mysql_query_rules (rule_id, active, match_pattern, destination_hostgroup, apply) VALUES
(3, 1, '^SELECT.*FOR UPDATE', 10, 1),  -- SELECT FOR UPDATE路由到主库
(4, 1, '^SELECT.*LOCK IN SHARE MODE', 10, 1),  -- SELECT LOCK IN SHARE MODE路由到主库
(5, 1, '^SELECT', 20, 1);  -- 其他SELECT路由到从库

-- 配置事务规则
INSERT INTO mysql_query_rules (rule_id, active, match_pattern, destination_hostgroup, apply) VALUES
(6, 1, '^BEGIN', 10, 1),  -- 事务开始路由到主库
(7, 1, '^COMMIT', 10, 1),  -- 事务提交路由到主库
(8, 1, '^ROLLBACK', 10, 1);  -- 事务回滚路由到主库
```

### 3. HAProxy

#### 3.1 基础配置
```ini
# HAProxy 配置文件
global
    daemon
    maxconn 4096
    user haproxy
    group haproxy

defaults
    mode tcp
    timeout connect 5000ms
    timeout client 50000ms
    timeout server 50000ms

# 主库配置
listen mysql_master
    bind *:3306
    mode tcp
    balance roundrobin
    option mysql-check user haproxy_check
    server master 192.168.1.10:3306 check

# 从库配置
listen mysql_slave
    bind *:3307
    mode tcp
    balance roundrobin
    option mysql-check user haproxy_check
    server slave1 192.168.1.11:3306 check
    server slave2 192.168.1.12:3306 check
```

#### 3.2 健康检查
```ini
# 健康检查配置
listen mysql_health
    bind *:3308
    mode tcp
    balance roundrobin
    option mysql-check user haproxy_check
    option httpchk
    http-check expect status 200
    server master 192.168.1.10:3306 check
    server slave1 192.168.1.11:3306 check backup
    server slave2 192.168.1.12:3306 check backup
```

## 中间件方案

### 1. Sharding-JDBC

#### 1.1 基础配置
```yaml
# application.yml
spring:
  datasource:
    names: ds0,ds1,ds2
    ds0:
      type: com.zaxxer.hikari.HikariDataSource
      driver-class-name: com.mysql.cj.jdbc.Driver
      jdbc-url: jdbc:mysql://192.168.1.10:3306/test
      username: root
      password: password
    ds1:
      type: com.zaxxer.hikari.HikariDataSource
      driver-class-name: com.mysql.cj.jdbc.Driver
      jdbc-url: jdbc:mysql://192.168.1.11:3306/test
      username: root
      password: password
    ds2:
      type: com.zaxxer.hikari.HikariDataSource
      driver-class-name: com.mysql.cj.jdbc.Driver
      jdbc-url: jdbc:mysql://192.168.1.12:3306/test
      username: root
      password: password

sharding:
  jdbc:
    datasource:
      names: ds0,ds1,ds2
    config:
      masterslave:
        name: ms
        master-data-source-name: ds0
        slave-data-source-names: ds1,ds2
        load-balance-algorithm-type: ROUND_ROBIN
```

#### 1.2 读写分离配置
```java
// 读写分离配置
@Configuration
public class ShardingJdbcConfig {
    
    @Bean
    public DataSource dataSource() throws SQLException {
        MasterSlaveRuleConfiguration masterSlaveRuleConfig = new MasterSlaveRuleConfiguration(
            "ms", "ds0", Arrays.asList("ds1", "ds2"));
        
        return MasterSlaveDataSourceFactory.createDataSource(
            createDataSourceMap(), masterSlaveRuleConfig, new Properties());
    }
    
    private Map<String, DataSource> createDataSourceMap() {
        Map<String, DataSource> result = new HashMap<>();
        result.put("ds0", createDataSource("jdbc:mysql://192.168.1.10:3306/test"));
        result.put("ds1", createDataSource("jdbc:mysql://192.168.1.11:3306/test"));
        result.put("ds2", createDataSource("jdbc:mysql://192.168.1.12:3306/test"));
        return result;
    }
}
```

### 2. MyCat

#### 2.1 配置文件
```xml
<!-- server.xml -->
<server>
    <user name="root">
        <property name="password">password</property>
        <property name="schemas">test</property>
    </user>
</server>

<!-- schema.xml -->
<schema name="test" checkSQLschema="false" sqlMaxLimit="100">
    <table name="user" primaryKey="id" dataNode="dn1" />
</schema>

<dataNode name="dn1" dataHost="localhost1" database="test" />

<dataHost name="localhost1" maxCon="1000" minCon="10" balance="1"
          writeType="0" dbType="mysql" dbDriver="native">
    <heartbeat>select user()</heartbeat>
    <writeHost host="hostM1" url="192.168.1.10:3306" user="root" password="password">
        <readHost host="hostS1" url="192.168.1.11:3306" user="root" password="password" />
        <readHost host="hostS2" url="192.168.1.12:3306" user="root" password="password" />
    </writeHost>
</dataHost>
```

#### 2.2 启动和监控
```bash
# 启动MyCat
./mycat start

# 检查MyCat状态
./mycat status

# 连接MyCat
mysql -h127.0.0.1 -P8066 -uroot -ppassword

# 查看MyCat日志
tail -f logs/mycat.log
```

## 性能优化

### 1. 连接池优化

#### 1.1 HikariCP配置
```yaml
# HikariCP 配置
spring:
  datasource:
    hikari:
      maximum-pool-size: 20
      minimum-idle: 5
      connection-timeout: 30000
      idle-timeout: 600000
      max-lifetime: 1800000
      leak-detection-threshold: 60000
```

#### 1.2 Druid配置
```yaml
# Druid 配置
spring:
  datasource:
    druid:
      initial-size: 5
      min-idle: 5
      max-active: 20
      max-wait: 60000
      time-between-eviction-runs-millis: 60000
      min-evictable-idle-time-millis: 300000
      validation-query: SELECT 1
      test-while-idle: true
      test-on-borrow: false
      test-on-return: false
```

### 2. 查询优化

#### 2.1 查询路由优化
```java
// 查询路由优化
@Component
public class QueryRouter {
    
    public DataSource routeDataSource(String sql) {
        if (isWriteOperation(sql)) {
            return masterDataSource;
        } else {
            return slaveDataSource;
        }
    }
    
    private boolean isWriteOperation(String sql) {
        String upperSql = sql.trim().toUpperCase();
        return upperSql.startsWith("INSERT") || 
               upperSql.startsWith("UPDATE") || 
               upperSql.startsWith("DELETE") ||
               upperSql.startsWith("CREATE") ||
               upperSql.startsWith("DROP") ||
               upperSql.startsWith("ALTER");
    }
}
```

#### 2.2 缓存优化
```java
// 缓存配置
@Configuration
@EnableCaching
public class CacheConfig {
    
    @Bean
    public CacheManager cacheManager() {
        RedisCacheManager cacheManager = RedisCacheManager.builder(redisConnectionFactory())
            .cacheDefaults(defaultConfig())
            .build();
        return cacheManager;
    }
    
    @Bean
    public RedisConnectionFactory redisConnectionFactory() {
        return new LettuceConnectionFactory();
    }
}
```

## 监控和告警

### 1. 性能监控

#### 1.1 关键指标
```sql
-- 监控读写分离效果
SELECT 
    'master' as data_source,
    COUNT(*) as query_count,
    AVG(query_time) as avg_query_time
FROM mysql.slow_log 
WHERE start_time > DATE_SUB(NOW(), INTERVAL 1 HOUR)
AND user_host LIKE '%master%'

UNION ALL

SELECT 
    'slave' as data_source,
    COUNT(*) as query_count,
    AVG(query_time) as avg_query_time
FROM mysql.slow_log 
WHERE start_time > DATE_SUB(NOW(), INTERVAL 1 HOUR)
AND user_host LIKE '%slave%';
```

#### 1.2 延迟监控
```sql
-- 监控从库延迟
SELECT 
    Seconds_Behind_Master,
    Slave_IO_Running,
    Slave_SQL_Running
FROM performance_schema.replication_connection_status;
```

### 2. 告警配置

#### 2.1 延迟告警
```bash
#!/bin/bash
# replication_delay_alert.sh

# 检查从库延迟
DELAY=$(mysql -uroot -ppassword -e "
SELECT Seconds_Behind_Master 
FROM performance_schema.replication_connection_status;" -s -N)

if [ "$DELAY" != "NULL" ] && [ $DELAY -gt 300 ]; then
    echo "从库延迟超过5分钟: ${DELAY}秒" | mail -s "MySQL复制延迟告警" admin@example.com
fi
```

#### 2.2 连接数告警
```bash
#!/bin/bash
# connection_alert.sh

# 检查主库连接数
MASTER_CONNECTIONS=$(mysql -h192.168.1.10 -uroot -ppassword -e "
SELECT COUNT(*) FROM information_schema.processlist;" -s -N)

# 检查从库连接数
SLAVE_CONNECTIONS=$(mysql -h192.168.1.11 -uroot -ppassword -e "
SELECT COUNT(*) FROM information_schema.processlist;" -s -N)

if [ $MASTER_CONNECTIONS -gt 100 ]; then
    echo "主库连接数过高: $MASTER_CONNECTIONS" | mail -s "MySQL连接数告警" admin@example.com
fi

if [ $SLAVE_CONNECTIONS -gt 200 ]; then
    echo "从库连接数过高: $SLAVE_CONNECTIONS" | mail -s "MySQL连接数告警" admin@example.com
fi
```

## 最佳实践

### 1. 设计原则

#### 1.1 数据一致性
- 确保主从数据同步
- 监控复制延迟
- 定期检查数据一致性

#### 1.2 高可用性
- 配置多个从库
- 实现自动故障转移
- 监控系统健康状态

### 2. 实施建议

#### 2.1 渐进式实施
```java
// 渐进式实施策略
@Component
public class ReadWriteSeparationManager {
    
    private boolean enabled = false;
    private double readSlaveRatio = 0.0; // 0.0-1.0
    
    public DataSource getDataSource(String sql) {
        if (!enabled) {
            return masterDataSource;
        }
        
        if (isReadOperation(sql) && Math.random() < readSlaveRatio) {
            return slaveDataSource;
        }
        
        return masterDataSource;
    }
    
    public void enableReadWriteSeparation() {
        this.enabled = true;
    }
    
    public void setReadSlaveRatio(double ratio) {
        this.readSlaveRatio = Math.min(1.0, Math.max(0.0, ratio));
    }
}
```

#### 2.2 监控和调优
- 监控读写比例
- 监控响应时间
- 根据业务需求调整策略

### 3. 故障处理

#### 3.1 常见问题
- 主从数据不一致
- 从库延迟过高
- 连接池耗尽
- 网络分区

#### 3.2 解决方案
- 定期数据一致性检查
- 优化网络配置
- 调整连接池参数
- 实现自动故障转移

## 总结

MySQL读写分离是提高数据库性能的重要策略：

1. **选择合适的方案**：根据业务需求选择应用层、代理层或中间件方案
2. **确保数据一致性**：监控复制延迟，定期检查数据一致性
3. **优化性能**：合理配置连接池，优化查询路由
4. **监控告警**：建立完善的监控和告警机制
5. **渐进实施**：采用渐进式实施策略，降低风险

通过合理的读写分离策略，可以显著提高MySQL数据库的性能和可扩展性。 