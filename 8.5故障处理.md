# 7.5 MySQL 复制故障处理

## 目录
- [1. 概述](#1-概述)
- [2. 故障诊断方法](#2-故障诊断方法)
- [3. 常见故障类型](#3-常见故障类型)
- [4. 网络故障处理](#4-网络故障处理)
- [5. 数据不一致处理](#5-数据不一致处理)
- [6. 从库故障处理](#6-从库故障处理)
- [7. 主库故障处理](#7-主库故障处理)
- [8. 自动化故障处理](#8-自动化故障处理)

## 1. 概述

MySQL复制故障处理是确保主从复制环境稳定运行的重要环节，包括故障诊断、问题定位、解决方案制定等。

### 1.1 故障处理流程

```mermaid
graph TD
    A[故障发现] --> B[故障诊断]
    B --> C[问题定位]
    C --> D[制定方案]
    D --> E[执行修复]
    E --> F[验证修复]
    F --> G[监控恢复]
    G --> H[记录总结]
```

### 1.2 故障分类

| 故障类型 | 常见原因 | 影响程度 | 处理优先级 |
|----------|----------|----------|------------|
| 网络故障 | 网络中断、防火墙 | 高 | 高 |
| 数据不一致 | 主从数据差异 | 高 | 高 |
| 从库故障 | 从库宕机、配置错误 | 中 | 中 |
| 主库故障 | 主库宕机、性能问题 | 高 | 高 |
| 配置错误 | 参数设置错误 | 中 | 中 |

## 2. 故障诊断方法

### 2.1 基本诊断命令

```sql
-- 查看复制状态
SHOW SLAVE STATUS\G

-- 查看主库状态
SHOW MASTER STATUS;

-- 查看错误日志
SHOW VARIABLES LIKE 'log_error';

-- 查看进程列表
SHOW PROCESSLIST;

-- 查看系统变量
SHOW VARIABLES LIKE '%replication%';
```

### 2.2 诊断脚本

```bash
#!/bin/bash
# MySQL复制故障诊断脚本

MASTER_HOST="192.168.1.100"
SLAVE_HOST="192.168.1.101"
MYSQL_USER="root"
MYSQL_PASSWORD="password"

echo "=== MySQL复制故障诊断 ==="
echo "时间: $(date)"
echo ""

# 1. 检查网络连通性
echo "1. 网络连通性检查:"
ping -c 3 $MASTER_HOST
ping -c 3 $SLAVE_HOST
echo ""

# 2. 检查MySQL服务状态
echo "2. MySQL服务状态检查:"
ssh $MASTER_HOST "systemctl status mysql"
ssh $SLAVE_HOST "systemctl status mysql"
echo ""

# 3. 检查复制状态
echo "3. 复制状态检查:"
mysql -h $SLAVE_HOST -u $MYSQL_USER -p$MYSQL_PASSWORD -e "SHOW SLAVE STATUS\G"
echo ""

# 4. 检查错误日志
echo "4. 错误日志检查:"
ssh $MASTER_HOST "tail -20 /var/log/mysql/error.log"
ssh $SLAVE_HOST "tail -20 /var/log/mysql/error.log"
echo ""

# 5. 检查磁盘空间
echo "5. 磁盘空间检查:"
ssh $MASTER_HOST "df -h"
ssh $SLAVE_HOST "df -h"
echo ""

# 6. 检查内存使用
echo "6. 内存使用检查:"
ssh $MASTER_HOST "free -h"
ssh $SLAVE_HOST "free -h"
echo ""
```

### 2.3 性能诊断

```sql
-- 查看复制性能指标
SELECT 
    VARIABLE_NAME,
    VARIABLE_VALUE
FROM performance_schema.global_status
WHERE VARIABLE_NAME LIKE '%slave%' 
   OR VARIABLE_NAME LIKE '%replication%';

-- 查看复制延迟
SELECT 
    MASTER_HOST,
    SECONDS_BEHIND_MASTER,
    SLAVE_IO_RUNNING,
    SLAVE_SQL_RUNNING
FROM performance_schema.replication_connection_status;

-- 查看复制错误
SELECT 
    MASTER_HOST,
    LAST_ERROR_NUMBER,
    LAST_ERROR_MESSAGE
FROM performance_schema.replication_connection_status;
```

## 3. 常见故障类型

### 3.1 复制停止故障

**症状**：
- `Slave_IO_Running: No`
- `Slave_SQL_Running: No`
- 复制完全停止

**诊断步骤**：
```sql
-- 1. 检查复制状态
SHOW SLAVE STATUS\G

-- 2. 查看错误信息
SELECT 
    LAST_ERROR,
    LAST_IO_ERROR,
    LAST_SQL_ERROR
FROM performance_schema.replication_connection_status;

-- 3. 检查主库状态
SHOW MASTER STATUS;
```

**解决方案**：
```sql
-- 1. 停止复制
STOP SLAVE;

-- 2. 重置复制（谨慎使用）
RESET SLAVE ALL;

-- 3. 重新配置复制
CHANGE MASTER TO
    MASTER_HOST = '192.168.1.100',
    MASTER_PORT = 3306,
    MASTER_USER = 'repl',
    MASTER_PASSWORD = 'repl_password',
    MASTER_LOG_FILE = 'mysql-bin.000001',
    MASTER_LOG_POS = 154;

-- 4. 启动复制
START SLAVE;
```

### 3.2 复制延迟故障

**症状**：
- `Seconds_Behind_Master` 值较大
- 从库数据落后于主库

**诊断步骤**：
```sql
-- 1. 查看延迟情况
SHOW SLAVE STATUS\G

-- 2. 检查网络延迟
SELECT 
    MASTER_HOST,
    MASTER_PORT,
    CONNECTION_STATUS
FROM performance_schema.replication_connection_status;

-- 3. 检查从库性能
SHOW PROCESSLIST;
```

**解决方案**：
```sql
-- 1. 优化从库配置
SET GLOBAL slave_parallel_workers = 4;
SET GLOBAL slave_parallel_type = 'LOGICAL_CLOCK';

-- 2. 检查网络带宽
-- 3. 优化主库写入频率
-- 4. 增加从库硬件资源
```

### 3.3 数据不一致故障

**症状**：
- 主从数据内容不同
- 复制错误日志显示数据冲突

**诊断步骤**：
```sql
-- 1. 使用pt-table-checksum检查数据一致性
pt-table-checksum --host=192.168.1.100 --user=root --password=password

-- 2. 查看具体的不一致表
SELECT 
    db,
    tbl,
    chunk,
    this_cnt,
    master_cnt,
    this_crc,
    master_crc
FROM checksums 
WHERE this_crc != master_crc;
```

**解决方案**：
```sql
-- 1. 使用pt-table-sync修复数据
pt-table-sync --host=192.168.1.100 --user=root --password=password

-- 2. 手动修复特定表
-- 在主库上导出数据
mysqldump -h 192.168.1.100 -u root -p database table > table.sql

-- 在从库上导入数据
mysql -h 192.168.1.101 -u root -p database < table.sql
```

## 4. 网络故障处理

### 4.1 网络连接故障

**症状**：
- 从库无法连接主库
- `Last_IO_Error` 显示连接错误

**诊断步骤**：
```bash
# 1. 检查网络连通性
ping 192.168.1.100
telnet 192.168.1.100 3306

# 2. 检查防火墙设置
iptables -L | grep 3306

# 3. 检查MySQL监听地址
netstat -tlnp | grep 3306
```

**解决方案**：
```bash
# 1. 修复网络连接
# 检查网络配置
ip route show

# 2. 配置防火墙
iptables -A INPUT -p tcp --dport 3306 -j ACCEPT

# 3. 检查MySQL绑定地址
# 在my.cnf中设置
bind-address = 0.0.0.0
```

### 4.2 网络延迟故障

**症状**：
- 复制延迟持续增加
- 网络延迟高

**诊断步骤**：
```bash
# 1. 测试网络延迟
ping -c 10 192.168.1.100

# 2. 使用iperf测试带宽
iperf -c 192.168.1.100 -t 60

# 3. 检查网络质量
mtr 192.168.1.100
```

**解决方案**：
```bash
# 1. 优化网络配置
# 调整TCP参数
echo 'net.core.rmem_max = 16777216' >> /etc/sysctl.conf
echo 'net.core.wmem_max = 16777216' >> /etc/sysctl.conf
sysctl -p

# 2. 使用专用网络
# 配置主从库之间的专用网络连接
```

## 5. 数据不一致处理

### 5.1 数据不一致检测

```sql
-- 创建数据一致性检查表
CREATE TABLE consistency_check (
    id INT AUTO_INCREMENT PRIMARY KEY,
    table_name VARCHAR(100),
    master_count INT,
    slave_count INT,
    check_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    status ENUM('OK', 'DIFFERENT', 'ERROR')
);

-- 检查表数据一致性
DELIMITER //
CREATE PROCEDURE check_table_consistency(IN db_name VARCHAR(100), IN tbl_name VARCHAR(100))
BEGIN
    DECLARE master_count INT;
    DECLARE slave_count INT;
    
    -- 获取主库记录数
    SELECT COUNT(*) INTO master_count 
    FROM information_schema.tables 
    WHERE table_schema = db_name AND table_name = tbl_name;
    
    -- 获取从库记录数
    SELECT COUNT(*) INTO slave_count 
    FROM information_schema.tables 
    WHERE table_schema = db_name AND table_name = tbl_name;
    
    -- 插入检查结果
    INSERT INTO consistency_check (table_name, master_count, slave_count, status)
    VALUES (tbl_name, master_count, slave_count, 
            CASE WHEN master_count = slave_count THEN 'OK' ELSE 'DIFFERENT' END);
END //
DELIMITER ;
```

### 5.2 数据修复方法

```sql
-- 方法1: 使用pt-table-sync修复
pt-table-sync --host=192.168.1.100 --user=root --password=password --print

-- 方法2: 手动修复特定表
-- 在主库上导出数据
mysqldump -h 192.168.1.100 -u root -p --single-transaction --routines --triggers database table > table.sql

-- 在从库上导入数据
mysql -h 192.168.1.101 -u root -p database < table.sql

-- 方法3: 使用SQL修复
-- 对于小表，可以直接执行SQL修复
UPDATE table_name SET column1 = value1 WHERE condition;
```

### 5.3 预防数据不一致

```sql
-- 1. 启用严格模式
SET GLOBAL sql_mode = 'STRICT_TRANS_TABLES,NO_ZERO_DATE,NO_ZERO_IN_DATE,ERROR_FOR_DIVISION_BY_ZERO';

-- 2. 定期检查数据一致性
-- 创建定时任务检查数据一致性
CREATE EVENT check_consistency_daily
ON SCHEDULE EVERY 1 DAY
STARTS CURRENT_TIMESTAMP
DO
BEGIN
    CALL check_table_consistency('database_name', 'table_name');
END;

-- 3. 使用事务确保数据一致性
START TRANSACTION;
-- 执行数据操作
COMMIT;
```

## 6. 从库故障处理

### 6.1 从库宕机处理

**症状**：
- 从库服务停止
- 无法连接从库

**处理步骤**：
```bash
# 1. 检查从库状态
systemctl status mysql

# 2. 启动从库服务
systemctl start mysql

# 3. 检查复制状态
mysql -u root -p -e "SHOW SLAVE STATUS\G"

# 4. 如果复制停止，重新启动复制
mysql -u root -p -e "START SLAVE;"
```

### 6.2 从库配置错误

**症状**：
- 复制启动失败
- 配置参数错误

**处理步骤**：
```sql
-- 1. 检查配置文件
SHOW VARIABLES LIKE 'server_id';
SHOW VARIABLES LIKE 'relay_log';

-- 2. 修正配置参数
SET GLOBAL server_id = 2;
SET GLOBAL relay_log = 'mysql-relay-bin';

-- 3. 重启MySQL服务
systemctl restart mysql
```

### 6.3 从库性能问题

**症状**：
- 从库响应慢
- 复制延迟增加

**处理步骤**：
```sql
-- 1. 优化从库配置
SET GLOBAL innodb_buffer_pool_size = 1073741824; -- 1GB
SET GLOBAL slave_parallel_workers = 4;
SET GLOBAL slave_parallel_type = 'LOGICAL_CLOCK';

-- 2. 检查硬件资源
-- 增加内存、CPU、磁盘I/O

-- 3. 优化查询
-- 分析慢查询日志
SHOW VARIABLES LIKE 'slow_query_log';
```

## 7. 主库故障处理

### 7.1 主库宕机处理

**症状**：
- 主库服务停止
- 从库无法连接主库

**处理步骤**：
```bash
# 1. 检查主库状态
systemctl status mysql

# 2. 启动主库服务
systemctl start mysql

# 3. 检查主库状态
mysql -u root -p -e "SHOW MASTER STATUS;"

# 4. 检查从库连接
mysql -u root -p -e "SHOW SLAVE STATUS\G"
```

### 7.2 主从切换

**场景**：主库故障，需要将从库提升为主库

**处理步骤**：
```sql
-- 1. 在从库上停止复制
STOP SLAVE;

-- 2. 重置复制
RESET SLAVE ALL;

-- 3. 启用写入
SET GLOBAL read_only = 0;
SET GLOBAL super_read_only = 0;

-- 4. 更新应用配置
-- 修改应用连接配置，指向新的主库

-- 5. 创建新的复制用户
CREATE USER 'repl'@'%' IDENTIFIED BY 'repl_password';
GRANT REPLICATION SLAVE ON *.* TO 'repl'@'%';
FLUSH PRIVILEGES;
```

### 7.3 主库性能问题

**症状**：
- 主库响应慢
- 写入性能下降

**处理步骤**：
```sql
-- 1. 优化主库配置
SET GLOBAL innodb_buffer_pool_size = 2147483648; -- 2GB
SET GLOBAL innodb_log_file_size = 268435456; -- 256MB
SET GLOBAL sync_binlog = 1;

-- 2. 检查慢查询
SHOW VARIABLES LIKE 'slow_query_log';
SHOW VARIABLES LIKE 'long_query_time';

-- 3. 优化索引
ANALYZE TABLE table_name;
OPTIMIZE TABLE table_name;
```

## 8. 自动化故障处理

### 8.1 故障检测脚本

```python
#!/usr/bin/env python3
# MySQL复制故障检测脚本

import mysql.connector
import time
import logging
import subprocess
from datetime import datetime

class ReplicationFaultDetector:
    def __init__(self, config):
        self.config = config
        self.setup_logging()
        
    def setup_logging(self):
        """设置日志"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler('fault_detector.log'),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger(__name__)
    
    def check_replication_health(self):
        """检查复制健康状态"""
        try:
            connection = mysql.connector.connect(
                host=self.config['slave_host'],
                user=self.config['user'],
                password=self.config['password'],
                database='mysql'
            )
            
            cursor = connection.cursor(dictionary=True)
            cursor.execute("SHOW SLAVE STATUS")
            result = cursor.fetchone()
            
            cursor.close()
            connection.close()
            
            return result
        except Exception as e:
            self.logger.error(f"检查复制状态失败: {e}")
            return None
    
    def detect_faults(self):
        """检测故障"""
        status = self.check_replication_health()
        
        if not status:
            return {'fault': 'connection_error', 'message': '无法连接从库'}
        
        faults = []
        
        # 检查I/O线程状态
        if status.get('Slave_IO_Running') != 'Yes':
            faults.append({
                'fault': 'io_thread_stopped',
                'message': 'I/O线程已停止',
                'error': status.get('Last_IO_Error', '')
            })
        
        # 检查SQL线程状态
        if status.get('Slave_SQL_Running') != 'Yes':
            faults.append({
                'fault': 'sql_thread_stopped',
                'message': 'SQL线程已停止',
                'error': status.get('Last_SQL_Error', '')
            })
        
        # 检查复制延迟
        lag = status.get('Seconds_Behind_Master')
        if lag is not None and lag > self.config['max_lag']:
            faults.append({
                'fault': 'high_replication_lag',
                'message': f'复制延迟过高: {lag}秒',
                'lag': lag
            })
        
        return faults
    
    def auto_fix_faults(self, faults):
        """自动修复故障"""
        for fault in faults:
            fault_type = fault['fault']
            
            if fault_type == 'io_thread_stopped':
                self.fix_io_thread_stopped()
            elif fault_type == 'sql_thread_stopped':
                self.fix_sql_thread_stopped()
            elif fault_type == 'high_replication_lag':
                self.fix_high_replication_lag()
    
    def fix_io_thread_stopped(self):
        """修复I/O线程停止"""
        try:
            connection = mysql.connector.connect(
                host=self.config['slave_host'],
                user=self.config['user'],
                password=self.config['password']
            )
            
            cursor = connection.cursor()
            cursor.execute("START SLAVE IO_THREAD")
            cursor.close()
            connection.close()
            
            self.logger.info("I/O线程已重启")
        except Exception as e:
            self.logger.error(f"修复I/O线程失败: {e}")
    
    def fix_sql_thread_stopped(self):
        """修复SQL线程停止"""
        try:
            connection = mysql.connector.connect(
                host=self.config['slave_host'],
                user=self.config['user'],
                password=self.config['password']
            )
            
            cursor = connection.cursor()
            cursor.execute("START SLAVE SQL_THREAD")
            cursor.close()
            connection.close()
            
            self.logger.info("SQL线程已重启")
        except Exception as e:
            self.logger.error(f"修复SQL线程失败: {e}")
    
    def fix_high_replication_lag(self):
        """修复高复制延迟"""
        # 这里可以实现更复杂的延迟修复逻辑
        self.logger.warning("检测到高复制延迟，需要人工干预")
    
    def run_detector(self):
        """运行故障检测器"""
        self.logger.info("开始MySQL复制故障检测")
        
        while True:
            try:
                faults = self.detect_faults()
                
                if faults:
                    self.logger.warning(f"检测到故障: {faults}")
                    
                    # 自动修复
                    if self.config.get('auto_fix', False):
                        self.auto_fix_faults(faults)
                    
                    # 发送告警
                    self.send_alert(faults)
                
                time.sleep(self.config['check_interval'])
                
            except KeyboardInterrupt:
                self.logger.info("故障检测停止")
                break
            except Exception as e:
                self.logger.error(f"故障检测异常: {e}")
                time.sleep(self.config['check_interval'])
    
    def send_alert(self, faults):
        """发送故障告警"""
        # 实现告警逻辑
        for fault in faults:
            self.logger.warning(f"故障告警: {fault['message']}")

# 配置示例
config = {
    'slave_host': '192.168.1.101',
    'user': 'root',
    'password': 'password',
    'max_lag': 300,  # 最大延迟5分钟
    'check_interval': 60,  # 检查间隔60秒
    'auto_fix': True  # 启用自动修复
}

if __name__ == "__main__":
    detector = ReplicationFaultDetector(config)
    detector.run_detector()
```

### 8.2 故障恢复脚本

```bash
#!/bin/bash
# MySQL复制故障恢复脚本

MASTER_HOST="192.168.1.100"
SLAVE_HOST="192.168.1.101"
MYSQL_USER="root"
MYSQL_PASSWORD="password"

# 恢复复制连接
restore_replication() {
    echo "开始恢复复制连接..."
    
    # 停止复制
    mysql -h $SLAVE_HOST -u $MYSQL_USER -p$MYSQL_PASSWORD -e "STOP SLAVE;"
    
    # 重置复制
    mysql -h $SLAVE_HOST -u $MYSQL_USER -p$MYSQL_PASSWORD -e "RESET SLAVE ALL;"
    
    # 获取主库状态
    MASTER_STATUS=$(mysql -h $MASTER_HOST -u $MYSQL_USER -p$MYSQL_PASSWORD -e "SHOW MASTER STATUS;" | tail -1)
    MASTER_LOG_FILE=$(echo $MASTER_STATUS | awk '{print $1}')
    MASTER_LOG_POS=$(echo $MASTER_STATUS | awk '{print $2}')
    
    # 重新配置复制
    mysql -h $SLAVE_HOST -u $MYSQL_USER -p$MYSQL_PASSWORD -e "
    CHANGE MASTER TO
        MASTER_HOST = '$MASTER_HOST',
        MASTER_PORT = 3306,
        MASTER_USER = 'repl',
        MASTER_PASSWORD = 'repl_password',
        MASTER_LOG_FILE = '$MASTER_LOG_FILE',
        MASTER_LOG_POS = $MASTER_LOG_POS;
    "
    
    # 启动复制
    mysql -h $SLAVE_HOST -u $MYSQL_USER -p$MYSQL_PASSWORD -e "START SLAVE;"
    
    echo "复制连接恢复完成"
}

# 检查复制状态
check_replication_status() {
    echo "检查复制状态..."
    mysql -h $SLAVE_HOST -u $MYSQL_USER -p$MYSQL_PASSWORD -e "SHOW SLAVE STATUS\G"
}

# 主函数
main() {
    echo "=== MySQL复制故障恢复 ==="
    echo "时间: $(date)"
    echo ""
    
    # 检查网络连通性
    if ! ping -c 1 $MASTER_HOST > /dev/null 2>&1; then
        echo "错误: 无法连接到主库 $MASTER_HOST"
        exit 1
    fi
    
    if ! ping -c 1 $SLAVE_HOST > /dev/null 2>&1; then
        echo "错误: 无法连接到从库 $SLAVE_HOST"
        exit 1
    fi
    
    # 恢复复制
    restore_replication
    
    # 检查状态
    check_replication_status
}

main
```

## 总结

MySQL复制故障处理需要：

1. **快速诊断**：准确识别故障类型
2. **及时处理**：根据故障类型采取相应措施
3. **预防为主**：建立完善的监控和预警机制
4. **自动化处理**：减少人工干预，提高恢复效率
5. **记录总结**：积累故障处理经验

通过系统化的故障处理流程，可以最大程度地减少复制故障对业务的影响。 