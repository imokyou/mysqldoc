# MySQL 备份恢复

## 概述

MySQL备份恢复是数据库管理中最重要的工作之一，是确保数据安全和业务连续性的关键措施。合理的备份策略和可靠的恢复机制可以最大程度地减少数据丢失风险，保障业务的稳定运行。

## 备份策略

### 1. 备份类型

#### 1.1 按备份方式分类

**物理备份**
- 直接复制数据文件
- 速度快，文件小
- 支持热备份和冷备份
- 工具：mysqldump、mysqlpump、Percona XtraBackup

**逻辑备份**
- 导出SQL语句
- 可读性好，跨版本兼容
- 速度较慢，文件较大
- 工具：mysqldump、mysqlpump

#### 1.2 按备份范围分类

**全量备份**
```bash
# 备份所有数据库
mysqldump --all-databases > full_backup.sql

# 备份指定数据库
mysqldump --databases db1 db2 > databases_backup.sql

# 备份单个数据库
mysqldump db_name > database_backup.sql
```

**增量备份**
```bash
# 基于二进制日志的增量备份
mysqlbinlog --start-datetime="2023-01-01 10:00:00" \
    --stop-datetime="2023-01-01 11:00:00" \
    mysql-bin.000001 > incremental_backup.sql
```

**差异备份**
```bash
# 基于上次全量备份的差异备份
# 使用Percona XtraBackup的增量备份功能
xtrabackup --backup --target-dir=/backup/inc1 \
    --incremental-basedir=/backup/base
```

### 2. 备份策略设计

#### 2.1 备份频率策略
```bash
# 每日全量备份
0 2 * * * /usr/local/bin/mysql_full_backup.sh

# 每小时增量备份
0 * * * * /usr/local/bin/mysql_incremental_backup.sh

# 每周完整备份
0 2 * * 0 /usr/local/bin/mysql_weekly_backup.sh
```

#### 2.2 备份保留策略
```bash
# 保留最近7天的每日备份
find /backup/daily -name "*.sql" -mtime +7 -delete

# 保留最近4周的周备份
find /backup/weekly -name "*.sql" -mtime +28 -delete

# 保留最近12个月的月备份
find /backup/monthly -name "*.sql" -mtime +365 -delete
```

## 备份工具

### 1. mysqldump

#### 1.1 基础备份命令
```bash
# 备份单个数据库
mysqldump -u root -p database_name > backup.sql

# 备份多个数据库
mysqldump -u root -p --databases db1 db2 > backup.sql

# 备份所有数据库
mysqldump -u root -p --all-databases > all_backup.sql

# 备份指定表
mysqldump -u root -p database_name table1 table2 > tables_backup.sql
```

#### 1.2 高级备份选项
```bash
# 一致性备份（推荐）
mysqldump -u root -p --single-transaction --routines --triggers \
    --all-databases > backup.sql

# 压缩备份
mysqldump -u root -p --all-databases | gzip > backup.sql.gz

# 加密备份
mysqldump -u root -p --all-databases | openssl enc -aes-256-cbc \
    -k 'password' > backup.sql.enc

# 并行备份
mysqldump -u root -p --parallel=4 --all-databases > backup.sql
```

#### 1.3 备份脚本示例
```bash
#!/bin/bash
# mysql_backup.sh

# 配置变量
MYSQL_USER="root"
MYSQL_PASS="password"
MYSQL_HOST="localhost"
MYSQL_PORT="3306"
BACKUP_DIR="/backup/mysql"
DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_FILE="${BACKUP_DIR}/backup_${DATE}.sql"

# 创建备份目录
mkdir -p $BACKUP_DIR

# 执行备份
mysqldump -u$MYSQL_USER -p$MYSQL_PASS -h$MYSQL_HOST -P$MYSQL_PORT \
    --single-transaction --routines --triggers --events \
    --all-databases > $BACKUP_FILE

# 压缩备份文件
gzip $BACKUP_FILE

# 删除7天前的备份
find $BACKUP_DIR -name "*.sql.gz" -mtime +7 -delete

echo "备份完成: ${BACKUP_FILE}.gz"
```

### 2. mysqlpump

#### 2.1 mysqlpump 特性
```bash
# 并行备份
mysqlpump -u root -p --parallel=4 --all-databases > backup.sql

# 排除特定数据库
mysqlpump -u root -p --exclude-databases=mysql,information_schema \
    --all-databases > backup.sql

# 包含特定数据库
mysqlpump -u root -p --databases db1 db2 > backup.sql

# 压缩输出
mysqlpump -u root -p --compress-output=ZLIB --all-databases > backup.sql.zlib
```

### 3. Percona XtraBackup

#### 3.1 物理备份
```bash
# 全量备份
xtrabackup --backup --target-dir=/backup/full

# 增量备份
xtrabackup --backup --target-dir=/backup/inc1 \
    --incremental-basedir=/backup/full

# 准备备份
xtrabackup --prepare --target-dir=/backup/full

# 复制备份到数据目录
xtrabackup --copy-back --target-dir=/backup/full
```

#### 3.2 流式备份
```bash
# 流式备份到远程服务器
xtrabackup --backup --stream=xbstream --target-dir=./ | \
    ssh user@remote_host "xbstream -x -C /backup/"

# 压缩流式备份
xtrabackup --backup --stream=xbstream --target-dir=./ | \
    gzip > backup.xbstream.gz
```

## 恢复方法

### 1. 逻辑备份恢复

#### 1.1 基础恢复命令
```bash
# 恢复单个数据库
mysql -u root -p database_name < backup.sql

# 恢复所有数据库
mysql -u root -p < all_backup.sql

# 恢复压缩备份
gunzip < backup.sql.gz | mysql -u root -p

# 恢复加密备份
openssl enc -aes-256-cbc -d -k 'password' < backup.sql.enc | \
    mysql -u root -p
```

#### 1.2 恢复脚本示例
```bash
#!/bin/bash
# mysql_restore.sh

# 配置变量
MYSQL_USER="root"
MYSQL_PASS="password"
MYSQL_HOST="localhost"
MYSQL_PORT="3306"
BACKUP_FILE="$1"

if [ -z "$BACKUP_FILE" ]; then
    echo "用法: $0 <backup_file>"
    exit 1
fi

# 检查备份文件是否存在
if [ ! -f "$BACKUP_FILE" ]; then
    echo "备份文件不存在: $BACKUP_FILE"
    exit 1
fi

# 停止应用服务（可选）
# systemctl stop myapp

# 恢复数据库
if [[ "$BACKUP_FILE" == *.gz ]]; then
    gunzip < "$BACKUP_FILE" | mysql -u$MYSQL_USER -p$MYSQL_PASS \
        -h$MYSQL_HOST -P$MYSQL_PORT
else
    mysql -u$MYSQL_USER -p$MYSQL_PASS -h$MYSQL_HOST -P$MYSQL_PORT < "$BACKUP_FILE"
fi

# 启动应用服务（可选）
# systemctl start myapp

echo "恢复完成: $BACKUP_FILE"
```

### 2. 物理备份恢复

#### 2.1 XtraBackup 恢复
```bash
# 准备备份
xtrabackup --prepare --target-dir=/backup/full

# 停止MySQL服务
systemctl stop mysql

# 备份当前数据目录
mv /var/lib/mysql /var/lib/mysql.old

# 复制备份到数据目录
xtrabackup --copy-back --target-dir=/backup/full

# 设置权限
chown -R mysql:mysql /var/lib/mysql

# 启动MySQL服务
systemctl start mysql
```

#### 2.2 流式备份恢复
```bash
# 解压流式备份
gunzip < backup.xbstream.gz | xbstream -x -C /backup/

# 准备备份
xtrabackup --prepare --target-dir=/backup

# 复制到数据目录
xtrabackup --copy-back --target-dir=/backup
```

### 3. 增量恢复

#### 3.1 基于二进制日志的恢复
```bash
# 恢复全量备份
mysql -u root -p < full_backup.sql

# 应用增量备份
mysql -u root -p < incremental_backup.sql

# 或者使用mysqlbinlog直接应用
mysqlbinlog mysql-bin.000001 | mysql -u root -p
```

#### 3.2 时间点恢复
```bash
# 恢复到指定时间点
mysqlbinlog --start-datetime="2023-01-01 10:00:00" \
    --stop-datetime="2023-01-01 11:00:00" \
    mysql-bin.000001 | mysql -u root -p
```

## 自动化备份

### 1. 完整备份脚本

#### 1.1 自动化备份脚本
```bash
#!/bin/bash
# auto_mysql_backup.sh

# 配置
MYSQL_USER="root"
MYSQL_PASS="password"
MYSQL_HOST="localhost"
BACKUP_DIR="/backup/mysql"
LOG_FILE="/var/log/mysql_backup.log"
RETENTION_DAYS=7

# 日志函数
log() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" >> $LOG_FILE
}

# 创建备份目录
mkdir -p $BACKUP_DIR

# 开始备份
log "开始MySQL备份"

# 执行备份
BACKUP_FILE="${BACKUP_DIR}/backup_$(date +%Y%m%d_%H%M%S).sql"

if mysqldump -u$MYSQL_USER -p$MYSQL_PASS -h$MYSQL_HOST \
    --single-transaction --routines --triggers --events \
    --all-databases > $BACKUP_FILE 2>> $LOG_FILE; then
    
    # 压缩备份
    gzip $BACKUP_FILE
    
    # 计算备份大小
    BACKUP_SIZE=$(du -h "${BACKUP_FILE}.gz" | cut -f1)
    
    log "备份成功: ${BACKUP_FILE}.gz (大小: $BACKUP_SIZE)"
    
    # 清理旧备份
    find $BACKUP_DIR -name "*.sql.gz" -mtime +$RETENTION_DAYS -delete
    log "清理了 $RETENTION_DAYS 天前的备份"
    
else
    log "备份失败"
    exit 1
fi

log "MySQL备份完成"
```

#### 1.2 增量备份脚本
```bash
#!/bin/bash
# incremental_backup.sh

# 配置
MYSQL_USER="root"
MYSQL_PASS="password"
BACKUP_DIR="/backup/mysql/incremental"
LOG_FILE="/var/log/mysql_incremental.log"

# 获取当前二进制日志位置
CURRENT_LOG=$(mysql -u$MYSQL_USER -p$MYSQL_PASS -e "SHOW MASTER STATUS\G" | grep File | awk '{print $2}')
CURRENT_POS=$(mysql -u$MYSQL_USER -p$MYSQL_PASS -e "SHOW MASTER STATUS\G" | grep Position | awk '{print $2}')

# 保存位置信息
echo "$CURRENT_LOG $CURRENT_POS" > $BACKUP_DIR/last_position.txt

# 获取上次备份位置
if [ -f "$BACKUP_DIR/last_backup_position.txt" ]; then
    LAST_LOG=$(cat $BACKUP_DIR/last_backup_position.txt | awk '{print $1}')
    LAST_POS=$(cat $BACKUP_DIR/last_backup_position.txt | awk '{print $2}')
    
    # 创建增量备份
    BACKUP_FILE="${BACKUP_DIR}/inc_$(date +%Y%m%d_%H%M%S).sql"
    
    mysqlbinlog --start-position=$LAST_POS \
        --stop-position=$CURRENT_POS \
        $LAST_LOG > $BACKUP_FILE
    
    echo "增量备份完成: $BACKUP_FILE"
fi

# 更新备份位置
echo "$CURRENT_LOG $CURRENT_POS" > $BACKUP_DIR/last_backup_position.txt
```

### 2. 监控和告警

#### 2.1 备份监控脚本
```bash
#!/bin/bash
# backup_monitor.sh

BACKUP_DIR="/backup/mysql"
ALERT_EMAIL="admin@example.com"

# 检查最新备份
LATEST_BACKUP=$(find $BACKUP_DIR -name "*.sql.gz" -type f -printf '%T@ %p\n' | sort -n | tail -1 | cut -d' ' -f2-)

if [ -z "$LATEST_BACKUP" ]; then
    echo "未找到备份文件" | mail -s "MySQL备份告警" $ALERT_EMAIL
    exit 1
fi

# 检查备份时间
BACKUP_TIME=$(stat -c %Y "$LATEST_BACKUP")
CURRENT_TIME=$(date +%s)
TIME_DIFF=$((CURRENT_TIME - BACKUP_TIME))

# 如果备份超过24小时，发送告警
if [ $TIME_DIFF -gt 86400 ]; then
    echo "MySQL备份超过24小时未更新" | mail -s "MySQL备份告警" $ALERT_EMAIL
fi

# 检查备份文件大小
BACKUP_SIZE=$(stat -c %s "$LATEST_BACKUP")
MIN_SIZE=1048576  # 1MB

if [ $BACKUP_SIZE -lt $MIN_SIZE ]; then
    echo "MySQL备份文件过小，可能备份失败" | mail -s "MySQL备份告警" $ALERT_EMAIL
fi
```

## 备份验证

### 1. 备份完整性检查

#### 1.1 语法检查
```bash
# 检查备份文件语法
mysql -u root -p --force < backup.sql

# 或者使用mysqlcheck
mysqlcheck -u root -p --all-databases
```

#### 1.2 恢复测试
```bash
#!/bin/bash
# backup_verify.sh

# 创建测试数据库
mysql -u root -p -e "CREATE DATABASE IF NOT EXISTS backup_test"

# 恢复备份到测试数据库
mysql -u root -p backup_test < backup.sql

# 检查表结构
mysql -u root -p -e "USE backup_test; SHOW TABLES;"

# 检查数据完整性
mysql -u root -p -e "USE backup_test; SELECT COUNT(*) FROM table_name;"

# 清理测试数据库
mysql -u root -p -e "DROP DATABASE backup_test"
```

### 2. 备份性能测试

#### 2.1 备份性能基准
```bash
#!/bin/bash
# backup_benchmark.sh

# 记录备份开始时间
START_TIME=$(date +%s)

# 执行备份
mysqldump -u root -p --all-databases > backup.sql

# 记录备份结束时间
END_TIME=$(date +%s)
BACKUP_TIME=$((END_TIME - START_TIME))

# 计算备份大小
BACKUP_SIZE=$(du -h backup.sql | cut -f1)

echo "备份时间: ${BACKUP_TIME}秒"
echo "备份大小: $BACKUP_SIZE"
```

## 最佳实践

### 1. 备份策略建议

#### 1.1 备份频率
- **生产环境**：每日全量备份 + 每小时增量备份
- **开发环境**：每周全量备份
- **测试环境**：按需备份

#### 1.2 备份存储
- **本地存储**：快速恢复
- **远程存储**：灾难恢复
- **云存储**：成本效益

### 2. 恢复策略建议

#### 2.1 恢复时间目标（RTO）
- **关键业务**：< 1小时
- **重要业务**：< 4小时
- **一般业务**：< 24小时

#### 2.2 恢复点目标（RPO）
- **关键业务**：< 15分钟
- **重要业务**：< 1小时
- **一般业务**：< 24小时

### 3. 安全考虑

#### 3.1 备份文件安全
```bash
# 设置备份文件权限
chmod 600 /backup/mysql/*.sql.gz
chown mysql:mysql /backup/mysql/*.sql.gz

# 加密备份文件
gpg --encrypt --recipient admin@example.com backup.sql
```

#### 3.2 传输安全
```bash
# 使用SSH传输备份
scp backup.sql.gz user@remote_host:/backup/

# 使用rsync同步备份
rsync -avz --delete /backup/mysql/ user@remote_host:/backup/
```

## 总结

MySQL备份恢复是数据库管理的核心工作，需要：

1. **制定合理的备份策略**：根据业务需求确定备份频率和方式
2. **选择适合的备份工具**：根据数据量和性能要求选择合适的工具
3. **建立自动化流程**：减少人工干预，提高备份可靠性
4. **定期验证备份**：确保备份文件完整性和可恢复性
5. **制定恢复计划**：明确恢复流程和责任人

通过以上措施，可以确保MySQL数据库的安全性和可用性。

**[返回目录 README.md](./README?id=_11-mysql-监控与维护)** 