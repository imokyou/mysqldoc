# MySQL 数据维护

## 概述

MySQL数据维护是确保数据库性能稳定和数据完整性的重要工作。通过定期的数据维护，可以优化查询性能、减少存储空间、提高系统稳定性。本文档将详细介绍MySQL数据维护的方法、工具和最佳实践。

## 表维护

### 1. 表结构维护

#### 1.1 表优化
```sql
-- 优化表结构
OPTIMIZE TABLE table_name;

-- 优化多个表
OPTIMIZE TABLE table1, table2, table3;

-- 优化指定数据库的所有表
SELECT CONCAT('OPTIMIZE TABLE ', table_schema, '.', table_name, ';') as optimize_statement
FROM information_schema.tables 
WHERE table_schema = 'your_database';
```

#### 1.2 表分析
```sql
-- 分析表统计信息
ANALYZE TABLE table_name;

-- 分析多个表
ANALYZE TABLE table1, table2, table3;

-- 分析指定数据库的所有表
SELECT CONCAT('ANALYZE TABLE ', table_schema, '.', table_name, ';') as analyze_statement
FROM information_schema.tables 
WHERE table_schema = 'your_database';
```

#### 1.3 表检查
```sql
-- 检查表结构
CHECK TABLE table_name;

-- 检查表并修复
CHECK TABLE table_name FOR UPGRADE;

-- 检查表的一致性
CHECK TABLE table_name EXTENDED;
```

### 2. 表修复

#### 2.1 修复损坏的表
```sql
-- 修复表
REPAIR TABLE table_name;

-- 修复表并优化
REPAIR TABLE table_name QUICK;

-- 修复表并重建索引
REPAIR TABLE table_name EXTENDED;
```

#### 2.2 修复脚本
```bash
#!/bin/bash
# table_repair.sh

MYSQL_USER="root"
MYSQL_PASS="password"
MYSQL_HOST="localhost"
DATABASE="$1"

if [ -z "$DATABASE" ]; then
    echo "用法: $0 <database_name>"
    exit 1
fi

# 获取需要修复的表
TABLES=$(mysql -u$MYSQL_USER -p$MYSQL_PASS -h$MYSQL_HOST -e "
SELECT table_name 
FROM information_schema.tables 
WHERE table_schema = '$DATABASE'
AND engine = 'MyISAM';" -s -N)

for TABLE in $TABLES; do
    echo "修复表: $DATABASE.$TABLE"
    mysql -u$MYSQL_USER -p$MYSQL_PASS -h$MYSQL_HOST -e "REPAIR TABLE $DATABASE.$TABLE;"
done

echo "表修复完成"
```

### 3. 表重建

#### 3.1 重建表结构
```sql
-- 重建表（InnoDB）
ALTER TABLE table_name ENGINE=InnoDB;

-- 重建表并优化
ALTER TABLE table_name ENGINE=InnoDB, ALGORITHM=INPLACE;

-- 重建表并复制数据
ALTER TABLE table_name ENGINE=InnoDB, ALGORITHM=COPY;
```

#### 3.2 重建大表
```sql
-- 分批重建大表
-- 创建新表
CREATE TABLE new_table LIKE old_table;

-- 分批复制数据
INSERT INTO new_table 
SELECT * FROM old_table 
WHERE id BETWEEN 1 AND 10000;

-- 继续复制剩余数据
INSERT INTO new_table 
SELECT * FROM old_table 
WHERE id BETWEEN 10001 AND 20000;

-- 完成后替换表
RENAME TABLE old_table TO old_table_backup, new_table TO old_table;
```

## 索引维护

### 1. 索引分析

#### 1.1 索引使用情况
```sql
-- 查看索引使用统计
SELECT 
    object_schema,
    object_name,
    index_name,
    count_star,
    sum_timer_wait/1000000000 as total_time_sec
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE object_schema = 'your_database'
ORDER BY sum_timer_wait DESC;
```

#### 1.2 未使用的索引
```sql
-- 查找未使用的索引
SELECT 
    t.table_schema,
    t.table_name,
    s.index_name,
    s.cardinality
FROM information_schema.tables t
JOIN information_schema.statistics s 
    ON t.table_schema = s.table_schema 
    AND t.table_name = s.table_name
WHERE t.table_schema = 'your_database'
AND s.cardinality = 0
AND s.index_name != 'PRIMARY';
```

### 2. 索引优化

#### 2.1 重建索引
```sql
-- 重建主键索引
ALTER TABLE table_name DROP PRIMARY KEY, ADD PRIMARY KEY (id);

-- 重建普通索引
ALTER TABLE table_name DROP INDEX index_name, ADD INDEX index_name (column_name);

-- 重建唯一索引
ALTER TABLE table_name DROP INDEX unique_index_name, 
    ADD UNIQUE INDEX unique_index_name (column_name);
```

#### 2.2 索引维护脚本
```bash
#!/bin/bash
# index_maintenance.sh

MYSQL_USER="root"
MYSQL_PASS="password"
MYSQL_HOST="localhost"
DATABASE="$1"

if [ -z "$DATABASE" ]; then
    echo "用法: $0 <database_name>"
    exit 1
fi

# 获取需要重建索引的表
TABLES=$(mysql -u$MYSQL_USER -p$MYSQL_PASS -h$MYSQL_HOST -e "
SELECT table_name 
FROM information_schema.tables 
WHERE table_schema = '$DATABASE'
AND engine = 'InnoDB';" -s -N)

for TABLE in $TABLES; do
    echo "优化表索引: $DATABASE.$TABLE"
    mysql -u$MYSQL_USER -p$MYSQL_PASS -h$MYSQL_HOST -e "OPTIMIZE TABLE $DATABASE.$TABLE;"
done

echo "索引维护完成"
```

### 3. 索引监控

#### 3.1 索引碎片监控
```sql
-- 查看索引碎片情况
SELECT 
    table_schema,
    table_name,
    index_name,
    cardinality,
    sub_part,
    packed,
    null,
    index_type
FROM information_schema.statistics
WHERE table_schema = 'your_database'
ORDER BY cardinality DESC;
```

#### 3.2 索引性能监控
```sql
-- 监控索引性能
SELECT 
    object_schema,
    object_name,
    index_name,
    count_star,
    sum_timer_wait/1000000000 as total_time_sec,
    avg_timer_wait/1000000 as avg_time_ms
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE object_schema = 'your_database'
ORDER BY sum_timer_wait DESC;
```

## 统计信息维护

### 1. 统计信息更新

#### 1.1 手动更新统计信息
```sql
-- 更新表统计信息
ANALYZE TABLE table_name;

-- 更新多个表统计信息
ANALYZE TABLE table1, table2, table3;

-- 更新数据库所有表统计信息
SELECT CONCAT('ANALYZE TABLE ', table_schema, '.', table_name, ';') as analyze_statement
FROM information_schema.tables 
WHERE table_schema = 'your_database';
```

#### 1.2 自动更新统计信息
```sql
-- 启用自动统计信息更新
SET GLOBAL innodb_stats_auto_recalc = ON;

-- 设置统计信息采样页数
SET GLOBAL innodb_stats_persistent_sample_pages = 20;

-- 手动更新统计信息
ANALYZE TABLE table_name;
```

### 2. 统计信息监控

#### 2.1 统计信息质量检查
```sql
-- 检查统计信息质量
SELECT 
    table_schema,
    table_name,
    table_rows,
    avg_row_length,
    data_length,
    max_data_length,
    index_length,
    data_free,
    auto_increment,
    create_time,
    update_time,
    check_time,
    table_collation,
    checksum,
    create_options,
    table_comment
FROM information_schema.tables
WHERE table_schema = 'your_database'
ORDER BY table_rows DESC;
```

#### 2.2 统计信息更新监控
```sql
-- 监控统计信息更新频率
SELECT 
    table_schema,
    table_name,
    update_time
FROM information_schema.tables
WHERE table_schema = 'your_database'
AND update_time IS NOT NULL
ORDER BY update_time DESC;
```

## 碎片整理

### 1. 表碎片整理

#### 1.1 InnoDB表碎片整理
```sql
-- 重建表以整理碎片
ALTER TABLE table_name ENGINE=InnoDB;

-- 使用OPTIMIZE TABLE整理碎片
OPTIMIZE TABLE table_name;

-- 分批整理大表碎片
-- 创建新表
CREATE TABLE new_table LIKE old_table;

-- 复制数据
INSERT INTO new_table SELECT * FROM old_table;

-- 替换表
RENAME TABLE old_table TO old_table_backup, new_table TO old_table;
```

#### 1.2 MyISAM表碎片整理
```sql
-- 整理MyISAM表碎片
OPTIMIZE TABLE table_name;

-- 修复MyISAM表
REPAIR TABLE table_name;

-- 重建MyISAM表
ALTER TABLE table_name ENGINE=MyISAM;
```

### 2. 索引碎片整理

#### 2.1 索引重建
```sql
-- 重建主键索引
ALTER TABLE table_name DROP PRIMARY KEY, ADD PRIMARY KEY (id);

-- 重建普通索引
ALTER TABLE table_name DROP INDEX index_name, ADD INDEX index_name (column_name);

-- 重建所有索引
SHOW INDEX FROM table_name;
-- 根据结果逐个重建索引
```

#### 2.2 碎片监控
```sql
-- 监控表碎片情况
SELECT 
    table_schema,
    table_name,
    data_length,
    data_free,
    ROUND(data_free / (data_length + data_free) * 100, 2) as fragmentation_percent
FROM information_schema.tables
WHERE table_schema = 'your_database'
AND data_free > 0
ORDER BY fragmentation_percent DESC;
```

## 数据清理

### 1. 过期数据清理

#### 1.1 基于时间的清理
```sql
-- 删除过期数据
DELETE FROM table_name 
WHERE created_at < DATE_SUB(NOW(), INTERVAL 1 YEAR);

-- 分批删除大表数据
DELETE FROM table_name 
WHERE id < 10000 
LIMIT 1000;

-- 使用存储过程分批删除
DELIMITER //
CREATE PROCEDURE cleanup_old_data()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE batch_size INT DEFAULT 1000;
    
    WHILE NOT done DO
        DELETE FROM table_name 
        WHERE created_at < DATE_SUB(NOW(), INTERVAL 1 YEAR)
        LIMIT batch_size;
        
        IF ROW_COUNT() < batch_size THEN
            SET done = TRUE;
        END IF;
        
        DO SLEEP(1); -- 避免锁表时间过长
    END WHILE;
END //
DELIMITER ;
```

#### 1.2 归档数据
```sql
-- 创建归档表
CREATE TABLE archive_table LIKE original_table;

-- 移动旧数据到归档表
INSERT INTO archive_table 
SELECT * FROM original_table 
WHERE created_at < DATE_SUB(NOW(), INTERVAL 1 YEAR);

-- 删除原表中的旧数据
DELETE FROM original_table 
WHERE created_at < DATE_SUB(NOW(), INTERVAL 1 YEAR);
```

### 2. 重复数据清理

#### 2.1 查找重复数据
```sql
-- 查找重复记录
SELECT column1, column2, COUNT(*) as count
FROM table_name
GROUP BY column1, column2
HAVING COUNT(*) > 1;

-- 删除重复数据（保留一条）
DELETE t1 FROM table_name t1
INNER JOIN table_name t2
WHERE t1.id > t2.id
AND t1.column1 = t2.column1
AND t1.column2 = t2.column2;
```

#### 2.2 数据去重脚本
```sql
-- 创建临时表存储重复数据
CREATE TABLE temp_duplicates AS
SELECT MIN(id) as min_id
FROM table_name
GROUP BY column1, column2
HAVING COUNT(*) > 1;

-- 删除重复数据
DELETE FROM table_name
WHERE id NOT IN (SELECT min_id FROM temp_duplicates);

-- 删除临时表
DROP TABLE temp_duplicates;
```

## 自动化维护

### 1. 维护脚本

#### 1.1 定期维护脚本
```bash
#!/bin/bash
# mysql_maintenance.sh

MYSQL_USER="root"
MYSQL_PASS="password"
MYSQL_HOST="localhost"
LOG_FILE="/var/log/mysql_maintenance.log"

# 日志函数
log() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" >> $LOG_FILE
}

# 获取需要维护的数据库
DATABASES=$(mysql -u$MYSQL_USER -p$MYSQL_PASS -h$MYSQL_HOST -e "SHOW DATABASES;" -s -N | grep -v -E "(mysql|information_schema|performance_schema)")

for DATABASE in $DATABASES; do
    log "开始维护数据库: $DATABASE"
    
    # 获取数据库中的表
    TABLES=$(mysql -u$MYSQL_USER -p$MYSQL_PASS -h$MYSQL_HOST -e "SHOW TABLES FROM $DATABASE;" -s -N)
    
    for TABLE in $TABLES; do
        log "维护表: $DATABASE.$TABLE"
        
        # 分析表
        mysql -u$MYSQL_USER -p$MYSQL_PASS -h$MYSQL_HOST -e "ANALYZE TABLE $DATABASE.$TABLE;"
        
        # 优化表（如果是InnoDB）
        mysql -u$MYSQL_USER -p$MYSQL_PASS -h$MYSQL_HOST -e "OPTIMIZE TABLE $DATABASE.$TABLE;"
    done
    
    log "完成数据库维护: $DATABASE"
done

log "MySQL维护完成"
```

#### 1.2 碎片整理脚本
```bash
#!/bin/bash
# defrag_tables.sh

MYSQL_USER="root"
MYSQL_PASS="password"
MYSQL_HOST="localhost"
DATABASE="$1"

if [ -z "$DATABASE" ]; then
    echo "用法: $0 <database_name>"
    exit 1
fi

# 获取需要整理的表
TABLES=$(mysql -u$MYSQL_USER -p$MYSQL_PASS -h$MYSQL_HOST -e "
SELECT table_name 
FROM information_schema.tables 
WHERE table_schema = '$DATABASE'
AND engine = 'InnoDB';" -s -N)

for TABLE in $TABLES; do
    echo "整理表碎片: $DATABASE.$TABLE"
    
    # 重建表以整理碎片
    mysql -u$MYSQL_USER -p$MYSQL_PASS -h$MYSQL_HOST -e "
    ALTER TABLE $DATABASE.$TABLE ENGINE=InnoDB;"
done

echo "碎片整理完成"
```

### 2. 监控和维护

#### 2.1 维护监控
```sql
-- 监控表大小变化
SELECT 
    table_schema,
    table_name,
    ROUND(((data_length + index_length) / 1024 / 1024), 2) as size_mb
FROM information_schema.tables
WHERE table_schema = 'your_database'
ORDER BY size_mb DESC;

-- 监控碎片情况
SELECT 
    table_schema,
    table_name,
    ROUND(data_free / (data_length + data_free) * 100, 2) as fragmentation_percent
FROM information_schema.tables
WHERE table_schema = 'your_database'
AND data_free > 0
ORDER BY fragmentation_percent DESC;
```

#### 2.2 维护计划
```bash
# crontab 配置
# 每日凌晨2点进行维护
0 2 * * * /usr/local/bin/mysql_maintenance.sh

# 每周日凌晨3点进行碎片整理
0 3 * * 0 /usr/local/bin/defrag_tables.sh your_database

# 每月1号凌晨4点进行深度维护
0 4 1 * * /usr/local/bin/deep_maintenance.sh
```

## 性能优化

### 1. 查询优化

#### 1.1 慢查询分析
```sql
-- 查看慢查询
SELECT 
    start_time,
    user_host,
    query_time,
    lock_time,
    rows_sent,
    rows_examined,
    sql_text
FROM mysql.slow_log
WHERE start_time > DATE_SUB(NOW(), INTERVAL 1 DAY)
ORDER BY query_time DESC;
```

#### 1.2 查询优化建议
```sql
-- 查找未使用索引的查询
SELECT 
    table_schema,
    table_name,
    index_name,
    cardinality
FROM information_schema.statistics
WHERE table_schema = 'your_database'
AND cardinality = 0
AND index_name != 'PRIMARY';
```

### 2. 存储优化

#### 2.1 存储空间优化
```sql
-- 查看表大小
SELECT 
    table_schema,
    table_name,
    ROUND(((data_length + index_length) / 1024 / 1024), 2) as size_mb
FROM information_schema.tables
WHERE table_schema = 'your_database'
ORDER BY size_mb DESC;

-- 查看数据库大小
SELECT 
    table_schema,
    ROUND(SUM(data_length + index_length) / 1024 / 1024, 2) as size_mb
FROM information_schema.tables
GROUP BY table_schema
ORDER BY size_mb DESC;
```

#### 2.2 压缩优化
```sql
-- 启用表压缩
ALTER TABLE table_name ROW_FORMAT=COMPRESSED KEY_BLOCK_SIZE=8;

-- 查看压缩效果
SELECT 
    table_name,
    row_format,
    table_comment
FROM information_schema.tables
WHERE table_schema = 'your_database';
```

## 最佳实践

### 1. 维护策略

#### 1.1 维护频率
- **日常维护**：每日分析表统计信息
- **周维护**：每周优化表和索引
- **月维护**：每月进行碎片整理
- **季度维护**：每季度进行深度维护

#### 1.2 维护时间
- 选择业务低峰期进行维护
- 避免在业务高峰期进行大表维护
- 使用维护窗口进行计划维护

### 2. 监控指标

#### 2.1 关键指标
- 表大小和增长率
- 索引使用效率
- 查询性能变化
- 存储空间使用率

#### 2.2 告警阈值
- 表碎片率 > 20%
- 索引基数 = 0
- 表大小增长率 > 50%
- 查询响应时间 > 5秒

### 3. 安全考虑

#### 3.1 备份策略
```bash
# 维护前备份
mysqldump -u root -p --all-databases > pre_maintenance_backup.sql

# 维护后验证
mysqlcheck -u root -p --all-databases
```

#### 3.2 回滚计划
```sql
-- 维护失败时的回滚
-- 从备份恢复
mysql -u root -p < pre_maintenance_backup.sql

-- 或者使用事务回滚
ROLLBACK;
```

## 总结

MySQL数据维护是确保数据库性能和数据完整性的重要工作：

1. **定期维护**：建立合理的维护计划和时间表
2. **监控指标**：关注关键性能指标和告警阈值
3. **自动化工具**：使用脚本和工具提高维护效率
4. **安全备份**：维护前进行备份，确保数据安全
5. **性能优化**：通过维护提高查询性能和存储效率

通过以上维护措施，可以确保MySQL数据库的稳定运行和最佳性能。 

**[返回目录 README.md](./README.md)** 