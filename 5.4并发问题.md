# 5.4 并发问题

## 概述

在数据库并发环境中，多个事务同时执行时会产生各种并发问题。这些问题是数据库系统需要解决的核心挑战，不同的隔离级别就是为了解决这些并发问题而设计的。

## 并发问题分类

### 1. 脏读（Dirty Read）

#### 定义
脏读是指一个事务读取到了另一个事务未提交的数据。如果那个未提交的事务最终回滚，那么读取到的数据就是无效的。

#### 产生条件
- 发生在**READ UNCOMMITTED**隔离级别
- 事务A修改数据但未提交
- 事务B读取到事务A未提交的数据

#### 详细示例

```sql
-- 创建测试表
CREATE TABLE test_dirty_read (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    balance DECIMAL(10,2)
);

INSERT INTO test_dirty_read VALUES (1, '张三', 1000.00);

-- 设置隔离级别为READ UNCOMMITTED
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

-- 事务A：修改数据但不提交
START TRANSACTION;
UPDATE test_dirty_read SET balance = 2000.00 WHERE id = 1;
-- 此时数据还未提交

-- 事务B：读取到未提交的数据（脏读）
START TRANSACTION;
SELECT balance FROM test_dirty_read WHERE id = 1;  -- 读取到2000.00
-- 基于这个未提交的数据做业务决策

-- 事务A回滚
ROLLBACK;

-- 事务B再次读取
SELECT balance FROM test_dirty_read WHERE id = 1;  -- 看到1000.00
-- 之前基于2000.00做的决策是错误的
COMMIT;
```

#### 脏读的危害

```sql
-- 演示脏读的危害
-- 事务A：银行转账
START TRANSACTION;
UPDATE accounts SET balance = balance - 500 WHERE account_id = 1;
UPDATE accounts SET balance = balance + 500 WHERE account_id = 2;
-- 转账过程中，数据还未提交

-- 事务B：生成余额报表（脏读）
START TRANSACTION;
SELECT account_id, balance FROM accounts WHERE account_id IN (1, 2);
-- 读取到未提交的余额，报表数据错误

-- 事务A回滚（转账失败）
ROLLBACK;

-- 事务B提交报表
COMMIT;
-- 报表基于错误数据生成，造成业务问题
```

#### 解决方案

```sql
-- 使用READ COMMITTED或更高级别的隔离级别
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- 事务A
START TRANSACTION;
UPDATE test_dirty_read SET balance = 2000.00 WHERE id = 1;

-- 事务B：无法读取到未提交的数据
START TRANSACTION;
SELECT balance FROM test_dirty_read WHERE id = 1;  -- 仍然看到1000.00
COMMIT;

-- 事务A提交
COMMIT;

-- 事务B再次读取
SELECT balance FROM test_dirty_read WHERE id = 1;  -- 现在看到2000.00
COMMIT;
```

### 2. 不可重复读（Non-repeatable Read）

#### 定义
不可重复读是指在一个事务内，多次读取同一数据，但读取到的结果不一致。这是因为在事务执行期间，其他事务修改了该数据并提交。

#### 产生条件
- 发生在**READ COMMITTED**隔离级别
- 事务A多次读取同一数据
- 事务B在事务A执行期间修改并提交了该数据

#### 详细示例

```sql
-- 设置隔离级别为READ COMMITTED
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- 事务A：多次读取同一数据
START TRANSACTION;
SELECT balance FROM test_dirty_read WHERE id = 1;  -- 第一次读取：1000.00

-- 事务B：修改数据并提交
START TRANSACTION;
UPDATE test_dirty_read SET balance = 1500.00 WHERE id = 1;
COMMIT;

-- 事务A再次读取
SELECT balance FROM test_dirty_read WHERE id = 1;  -- 第二次读取：1500.00
-- 同一事务内两次读取结果不一致
COMMIT;
```

#### 不可重复读的危害

```sql
-- 演示不可重复读的危害
-- 事务A：生成财务报表
START TRANSACTION;
-- 第一次读取：计算总资产
SELECT SUM(balance) as total_assets FROM accounts;  -- 返回10000.00

-- 事务B：执行转账
START TRANSACTION;
UPDATE accounts SET balance = balance - 1000 WHERE account_id = 1;
UPDATE accounts SET balance = balance + 1000 WHERE account_id = 2;
COMMIT;

-- 事务A继续处理
-- 第二次读取：计算平均余额
SELECT AVG(balance) as avg_balance FROM accounts;  -- 基于新的余额计算
-- 报表数据不一致
COMMIT;
```

#### 解决方案

```sql
-- 使用REPEATABLE READ隔离级别
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;

-- 事务A：多次读取结果一致
START TRANSACTION;
SELECT balance FROM test_dirty_read WHERE id = 1;  -- 第一次读取

-- 事务B：修改数据并提交
START TRANSACTION;
UPDATE test_dirty_read SET balance = 2000.00 WHERE id = 1;
COMMIT;

-- 事务A再次读取
SELECT balance FROM test_dirty_read WHERE id = 1;  -- 仍然看到之前的值
-- 同一事务内读取结果一致
COMMIT;
```

### 3. 幻读（Phantom Read）

#### 定义
幻读是指在一个事务内，多次执行相同的查询，但查询结果集发生变化。这是因为在事务执行期间，其他事务插入了符合查询条件的新数据。

#### 产生条件
- 发生在**REPEATABLE READ**隔离级别
- 事务A执行范围查询
- 事务B在事务A执行期间插入符合条件的新数据

#### 详细示例

```sql
-- 创建测试表
CREATE TABLE test_phantom (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50),
    amount DECIMAL(10,2)
);

INSERT INTO test_phantom (name, amount) VALUES 
('产品A', 100.00),
('产品B', 200.00),
('产品C', 300.00);

-- 设置隔离级别为REPEATABLE READ
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;

-- 事务A：查询金额大于150的产品
START TRANSACTION;
SELECT COUNT(*) FROM test_phantom WHERE amount > 150;  -- 返回2

-- 事务B：插入新记录
START TRANSACTION;
INSERT INTO test_phantom (name, amount) VALUES ('产品D', 400.00);
COMMIT;

-- 事务A再次查询
SELECT COUNT(*) FROM test_phantom WHERE amount > 150;  -- 仍然返回2
-- 但是范围查询可能看到新插入的数据
SELECT * FROM test_phantom WHERE amount > 150;  -- 可能看到产品D
COMMIT;
```

#### 幻读的危害

```sql
-- 演示幻读的危害
-- 事务A：库存检查
START TRANSACTION;
-- 检查库存充足的产品
SELECT COUNT(*) FROM products WHERE stock > 10;  -- 返回5个产品

-- 事务B：创建订单
START TRANSACTION;
INSERT INTO orders (product_id, quantity) VALUES (1, 5);
UPDATE products SET stock = stock - 5 WHERE product_id = 1;
COMMIT;

-- 事务A继续处理
-- 基于之前的检查结果做决策
-- 但实际情况已经发生变化
COMMIT;
```

#### 解决方案

```sql
-- 使用SERIALIZABLE隔离级别
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;

-- 事务A：查询会被阻塞直到其他事务完成
START TRANSACTION;
SELECT COUNT(*) FROM test_phantom WHERE amount > 150;

-- 事务B：插入操作会被阻塞
START TRANSACTION;
INSERT INTO test_phantom (name, amount) VALUES ('产品E', 500.00);
-- 这个操作会被阻塞，直到事务A提交或回滚

-- 事务A提交
COMMIT;

-- 事务B现在可以继续执行
COMMIT;
```

### 4. 丢失更新（Lost Update）

#### 定义
丢失更新是指两个事务同时读取同一数据，然后各自修改并提交，导致后提交的事务覆盖了先提交的事务的修改。

#### 产生条件
- 发生在任何隔离级别
- 两个事务同时读取同一数据
- 都基于读取的数据进行修改
- 后提交的事务覆盖了先提交的事务的修改

#### 详细示例

```sql
-- 创建测试表
CREATE TABLE test_lost_update (
    id INT PRIMARY KEY,
    balance DECIMAL(10,2)
);

INSERT INTO test_lost_update VALUES (1, 1000.00);

-- 事务A：读取余额并准备扣款
START TRANSACTION;
SELECT balance FROM test_lost_update WHERE id = 1;  -- 读取1000.00
-- 计算新余额：1000.00 - 100 = 900.00

-- 事务B：同时读取余额并准备扣款
START TRANSACTION;
SELECT balance FROM test_lost_update WHERE id = 1;  -- 也读取1000.00
-- 计算新余额：1000.00 - 200 = 800.00

-- 事务A提交
UPDATE test_lost_update SET balance = 900.00 WHERE id = 1;
COMMIT;

-- 事务B提交（覆盖了事务A的修改）
UPDATE test_lost_update SET balance = 800.00 WHERE id = 1;
COMMIT;

-- 最终余额是800.00，事务A的修改丢失了
SELECT balance FROM test_lost_update WHERE id = 1;  -- 返回800.00
```

#### 丢失更新的危害

```sql
-- 演示丢失更新的危害
-- 事务A：用户A购买商品
START TRANSACTION;
SELECT stock FROM products WHERE product_id = 1;  -- 库存100
-- 用户A购买5个，新库存应该是95

-- 事务B：用户B同时购买同一商品
START TRANSACTION;
SELECT stock FROM products WHERE product_id = 1;  -- 库存100
-- 用户B购买3个，新库存应该是97

-- 事务A提交
UPDATE products SET stock = 95 WHERE product_id = 1;
COMMIT;

-- 事务B提交（覆盖了事务A的修改）
UPDATE products SET stock = 97 WHERE product_id = 1;
COMMIT;

-- 最终库存是97，但实际应该扣除8个，库存应该是92
SELECT stock FROM products WHERE product_id = 1;  -- 返回97
```

#### 解决方案

```sql
-- 方案1：使用SELECT FOR UPDATE
-- 事务A
START TRANSACTION;
SELECT balance FROM test_lost_update WHERE id = 1 FOR UPDATE;  -- 获取行锁
UPDATE test_lost_update SET balance = balance - 100 WHERE id = 1;
COMMIT;

-- 事务B会被阻塞，直到事务A完成
START TRANSACTION;
SELECT balance FROM test_lost_update WHERE id = 1 FOR UPDATE;  -- 等待锁释放
UPDATE test_lost_update SET balance = balance - 200 WHERE id = 1;
COMMIT;
```

```sql
-- 方案2：使用乐观锁
-- 添加版本字段
ALTER TABLE test_lost_update ADD COLUMN version INT DEFAULT 1;

-- 事务A
START TRANSACTION;
SELECT balance, version FROM test_lost_update WHERE id = 1;
-- 读取到balance=1000.00, version=1
UPDATE test_lost_update SET balance = 900.00, version = 2 
WHERE id = 1 AND version = 1;  -- 只有版本匹配才更新
COMMIT;

-- 事务B
START TRANSACTION;
SELECT balance, version FROM test_lost_update WHERE id = 1;
-- 读取到balance=900.00, version=2
UPDATE test_lost_update SET balance = 700.00, version = 3 
WHERE id = 1 AND version = 2;
COMMIT;
```

## 并发问题的检测和监控

### 1. 检测并发问题

```sql
-- 监控锁等待
SELECT 
    r.trx_id waiting_trx_id,
    r.trx_mysql_thread_id waiting_thread,
    r.trx_query waiting_query,
    b.trx_id blocking_trx_id,
    b.trx_mysql_thread_id blocking_thread,
    b.trx_query blocking_query,
    TIMESTAMPDIFF(SECOND, r.trx_started, NOW()) as wait_time
FROM information_schema.innodb_lock_waits w
INNER JOIN information_schema.innodb_trx b ON b.trx_id = w.blocking_trx_id
INNER JOIN information_schema.innodb_trx r ON r.trx_id = w.requesting_trx_id;
```

### 2. 监控事务状态

```sql
-- 查看长时间运行的事务
SELECT 
    trx_id,
    trx_state,
    trx_started,
    trx_mysql_thread_id,
    trx_query,
    TIMESTAMPDIFF(SECOND, trx_started, NOW()) as duration_seconds
FROM information_schema.innodb_trx
WHERE trx_state = 'RUNNING'
ORDER BY duration_seconds DESC;
```

### 3. 监控死锁

```sql
-- 查看死锁信息
SHOW ENGINE INNODB STATUS\G

-- 查看最近的死锁
SELECT 
    latest_deadlock
FROM performance_schema.events_statements_history_long
WHERE event_name = 'statement/sql/show_engine_innodb_status';
```

## 预防并发问题的策略

### 1. 合理设计事务

```sql
-- 避免长事务
-- 错误示例
START TRANSACTION;
-- 执行大量操作
-- 长时间不提交
-- COMMIT;

-- 正确示例：将大事务拆分为小事务
START TRANSACTION;
-- 执行少量操作
COMMIT;

START TRANSACTION;
-- 执行下一批操作
COMMIT;
```

### 2. 使用适当的锁策略

```sql
-- 使用行锁而不是表锁
SELECT * FROM accounts WHERE id = 1 FOR UPDATE;  -- 行锁

-- 避免不必要的锁
SELECT * FROM accounts WHERE id = 1;  -- 普通查询，不需要锁

-- 使用共享锁进行读操作
SELECT * FROM accounts WHERE id = 1 LOCK IN SHARE MODE;
```

### 3. 使用乐观锁

```sql
-- 添加版本字段
ALTER TABLE products ADD COLUMN version INT DEFAULT 1;

-- 更新时检查版本
UPDATE products 
SET stock = stock - 1, version = version + 1 
WHERE product_id = 1 AND version = 1;

-- 检查更新是否成功
SELECT ROW_COUNT();
```

### 4. 使用数据库约束

```sql
-- 使用CHECK约束
ALTER TABLE accounts 
ADD CONSTRAINT chk_balance 
CHECK (balance >= 0);

-- 使用唯一约束
ALTER TABLE users 
ADD CONSTRAINT uk_email 
UNIQUE (email);
```

## 实际应用示例

### 1. 银行转账系统

```sql
-- 安全的转账实现
START TRANSACTION;

-- 检查账户是否存在
SELECT account_id, balance FROM accounts 
WHERE account_id IN (1, 2) FOR UPDATE;

-- 验证余额是否充足
SELECT balance FROM accounts WHERE account_id = 1;
IF balance < 100 THEN
    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '余额不足';
END IF;

-- 执行转账
UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;
UPDATE accounts SET balance = balance + 100 WHERE account_id = 2;

-- 验证转账结果
SELECT SUM(balance) FROM accounts WHERE account_id IN (1, 2);
-- 确保总金额不变

COMMIT;
```

### 2. 库存管理系统

```sql
-- 安全的库存扣减
START TRANSACTION;

-- 检查库存
SELECT stock FROM products WHERE product_id = 1 FOR UPDATE;

-- 扣减库存
UPDATE products SET stock = stock - 1 
WHERE product_id = 1 AND stock > 0;

-- 检查是否扣减成功
IF ROW_COUNT() = 0 THEN
    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '库存不足';
END IF;

-- 创建订单
INSERT INTO orders (product_id, quantity, status) 
VALUES (1, 1, 'confirmed');

COMMIT;
```

## 总结

并发问题是数据库系统必须解决的核心挑战：

1. **脏读**：通过READ COMMITTED或更高级别解决
2. **不可重复读**：通过REPEATABLE READ或更高级别解决
3. **幻读**：通过SERIALIZABLE解决
4. **丢失更新**：通过锁机制或乐观锁解决

在实际应用中，需要根据业务需求选择合适的隔离级别和锁策略，在性能和一致性之间找到平衡点。 